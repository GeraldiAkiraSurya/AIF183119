1
00:00:00,060 --> 00:00:02,500
Konten berikut diberikan
di bawah lisensi

2
00:00:02,500 --> 00:00:04,019
Creative Commons.

3
00:00:04,019 --> 00:00:06,360
Dukungan Anda akan membantu
MIT OpenCourseWare

4
00:00:06,360 --> 00:00:10,730
untuk terus menyediakan bahan edukasi
berkualitas tinggi secara gratis

5
00:00:10,730 --> 00:00:13,330
Untuk berdonasi, atau
melihat materi tambahan

6
00:00:13,330 --> 00:00:17,236
dari ratusan kuliah MIT,
kunjungi MIT OpenCourseWare

7
00:00:17,236 --> 00:00:17,861
di ocw.mit.edu.

8
00:00:20,364 --> 00:00:21,530
SRINIVAS DEVADAS: Baiklah.

9
00:00:21,530 --> 00:00:23,860
Selamat pagi, semuanya.

10
00:00:23,860 --> 00:00:29,780
Jadi kurang lebih sama dalam hal
kriptografi dan teknik

11
00:00:29,780 --> 00:00:32,750
kriptografis pada kuliah
hari Selasa.

12
00:00:32,750 --> 00:00:35,430
Jadi jika Anda menyukainya,
Anda akan suka dengan yang ini.

13
00:00:35,430 --> 00:00:37,180
Kalau Anda tidak suka,
baiklah, itu

14
00:00:37,180 --> 00:00:41,020
akan kurang lebih
sama, mohon maaf.

15
00:00:41,020 --> 00:00:44,340
Tapi apa yang akan kita
lakukan hari ini adalah

16
00:00:44,340 --> 00:00:47,840
melakukan beberapa hal
yang sedikit berbeda.

17
00:00:47,840 --> 00:00:49,760
Kita akan berbicara
tentang enkripsi.

18
00:00:49,760 --> 00:00:51,660
Jadi kita sudah berbicara tentang
hash, yang mana, tentu saja,

19
00:00:51,660 --> 00:00:55,150
Anda tahu tentangnya dari
penggunaan kamus.

20
00:00:55,150 --> 00:00:58,770
Kita tidak terlalu bicara soal
enkripsi di (kuliah) 046 atau bahkan

21
00:00:58,770 --> 00:01:02,770
di 006 sebelumnya.

22
00:01:02,770 --> 00:01:07,940
Tapi kita akan melihat dua jenis
berbeda dari algoritme enkripsi.

23
00:01:07,940 --> 00:01:11,950
Kita akan menghabiskan sedikit waktu
pada enkripsi kunci simetris,

24
00:01:11,950 --> 00:01:15,310
yang mana merupakan sesuatu yang penting
yang digunakan pada mesin encoding

25
00:01:15,310 --> 00:01:21,180
termasuk enigma dari Perang
Dunia II yang mungkin Anda lihat

26
00:01:21,180 --> 00:01:23,190
jika Anda melihat The Imitation Game.

27
00:01:23,190 --> 00:01:26,410
Jadi Anda memiliki sebuah
(kunci) rahasia yang dibagikan.

28
00:01:26,410 --> 00:01:28,560
Dan satu buah itulah,
yang dinamakan,

29
00:01:28,560 --> 00:01:29,910
"symmetric shared secret".

30
00:01:29,910 --> 00:01:32,320
Kedua pihak mengetahui rahasianya.

31
00:01:32,320 --> 00:01:37,570
Dan dengan singkat, kita
akan berbicara tentang apa artinya

32
00:01:37,570 --> 00:01:39,620
untuk bertukar rahasia.

33
00:01:39,620 --> 00:01:41,360
Jadi kita akan bicara
tentang pertukaran kunci.

34
00:01:41,360 --> 00:01:45,350
Dan saya akan pindah
ke enkripsi kunci asimetris, di mana

35
00:01:45,350 --> 00:01:47,240
saya menyinggung
sedikit saat kita

36
00:01:47,240 --> 00:01:49,520
bicara tentang tanda tangan
dijital sebelumnya.

37
00:01:49,520 --> 00:01:51,860
Saya bicara tentang kunci
publik dan kunci privat.

38
00:01:51,860 --> 00:01:53,700
Tapi kita akan
melihat pada beberapa

39
00:01:53,700 --> 00:01:56,840
jenis algoritme enkripsi
kunci publik hari ini.

40
00:01:56,840 --> 00:02:00,650
Algoritme klasik, algoritme
pertama sekali yang 

41
00:02:00,650 --> 00:02:04,520
masih aman,
yaitu algoritme RSA.

42
00:02:04,520 --> 00:02:07,270
Singkatan dari Rivest,
Shamir, dan Adleman,

43
00:02:07,270 --> 00:02:09,139
inisial dari
ketiga pembuatnya,

44
00:02:09,139 --> 00:02:14,990
diciptakan di MIT pada tahun 1977
dan masih digunakan sekarang.

45
00:02:14,990 --> 00:02:17,410
Dan bagian terakhir
dari kuliah hari ini

46
00:02:17,410 --> 00:02:21,220
adalah akan melihat
kesulitannya

47
00:02:21,220 --> 00:02:25,840
Jadi di dalam enkripsi, jika Anda
tidak tahu kunci rahasia,

48
00:02:25,840 --> 00:02:28,830
harusnya sangat sulit
bagi seorang penyerang

49
00:02:28,830 --> 00:02:33,040
untuk mengetahui apakah
isi pesannya.

50
00:02:33,040 --> 00:02:36,040
Penyerang melihat apa yang
disebut sebagai cipher text, yang

51
00:02:36,040 --> 00:02:38,270
merupakan teks yang terenkripsi.

52
00:02:38,270 --> 00:02:40,890
Penyerang tidak tahu
kunci rahasianya.

53
00:02:40,890 --> 00:02:43,990
Jika dia tahu kata kuncinya,
permainan berakhir.

54
00:02:43,990 --> 00:02:47,280
Tapi mengasumsikan penyerang
tidak tahu kunci rahasianya,

55
00:02:47,280 --> 00:02:51,810
seharusnya sulit untuk
mengetahui pesannya, bukan?

56
00:02:51,810 --> 00:02:53,340
Masuk akal.

57
00:02:53,340 --> 00:02:55,510
Jadi jelas ada
relasi

58
00:02:55,510 --> 00:02:59,840
antara kesulitan ini
dan masalah NP-complete (non-polinomial),

59
00:02:59,840 --> 00:03:01,930
yang secara komputasi sulit.

60
00:03:01,930 --> 00:03:04,520
Dan tidak mengejutkan
bahwa orang-orang

61
00:03:04,520 --> 00:03:08,230
sudah mencoba untuk membangun
apa yang disebut kriptosistem, yang

62
00:03:08,230 --> 00:03:10,830
pada dasarnya teknik-teknik
kriptografi, berdasarkan

63
00:03:10,830 --> 00:03:13,540
pada kesulitan dari
masalah-masalah NP-complete

64
00:03:13,540 --> 00:03:15,430
termasuk pewarnaan
graf dan knapsack

65
00:03:15,430 --> 00:03:16,810
dan seterusnya.

66
00:03:16,810 --> 00:03:21,260
Tetapi ternyata ada
perbedaan mendasar

67
00:03:21,260 --> 00:03:28,520
antara masalah-masalah
yang bermanfaat dalam hal

68
00:03:28,520 --> 00:03:31,490
membangun kriptosistem
yang aman seperti RSA

69
00:03:31,490 --> 00:03:33,320
dengan masalah-masalah NP-complete.

70
00:03:33,320 --> 00:03:36,140
Dan kita akan membicarakannya
di akhir kuliah.

71
00:03:36,140 --> 00:03:38,960
Kita mungkin akan menghabiskan
sedikit waktu pada hal itu.

72
00:03:38,960 --> 00:03:43,230
Jadi mari kita mulai dengan
enkripsi kunci simetris, yang

73
00:03:43,230 --> 00:03:45,130
pada tingkatan tertentu,
membosankan

74
00:03:45,130 --> 00:03:46,870
dari sudut pandang matematis.

75
00:03:46,870 --> 00:03:49,380
Jadi kita (tidak?) ingin menghabiskan
banyak waktu pada hal tersebut.

76
00:03:49,380 --> 00:03:51,520
Tentu saja itu sangat bermanfaat.

77
00:03:51,520 --> 00:03:57,280
Pada dasarnya diasumsikan bahwa
ada kunci rahasia k.

78
00:03:57,280 --> 00:04:00,760
Dan Anda bisa menganggap ini
sebagai bilangan 128-bit.

79
00:04:00,760 --> 00:04:04,280
Beberapa orang ingin ukurannya
lebih besar, 256.

80
00:04:04,280 --> 00:04:06,670
Tetapi tiba-tiba saja 64.

81
00:04:06,670 --> 00:04:09,960
Pada titik ini,
mungkin tidak cukup,

82
00:04:09,960 --> 00:04:13,380
walaupun 2 pangkat 64 adalah
bilangan yang cukup besar.

83
00:04:13,380 --> 00:04:18,700
Dengan komputasi paralel
dan komputer yang cepat,

84
00:04:18,700 --> 00:04:22,250
agak sedikit mengkhawatirkan
bahwa penyerang hanya

85
00:04:22,250 --> 00:04:25,820
membutuhkan 2 pangkat 64 usaha
untuk mengenumerasi

86
00:04:25,820 --> 00:04:30,160
seluruh kemungkinan kunci
rahasia dari 64-bit bukan?

87
00:04:30,160 --> 00:04:33,910
Jadi (2?) pangkat
128 jauh lebih baik.

88
00:04:33,910 --> 00:04:37,830
Dan ini dibagikan
antara Alice dan Bob.

89
00:04:37,830 --> 00:04:41,330
Jadi kita akan bicara
tentang protagonisnya

90
00:04:41,330 --> 00:04:44,420
di sini yaitu Alice dan Bob.

91
00:04:44,420 --> 00:04:47,440
Dan mereka ingin
bertukar informasi.

92
00:04:47,440 --> 00:04:51,770
Dan biasanya, penyerang
dikatakan sebagai mal untuk malicious.

93
00:04:54,770 --> 00:04:58,565
Tentu saja ada cara lain Anda
dapat menamakan sang penyerang.

94
00:05:01,080 --> 00:05:05,120
Jadi persamaan dasarnya di sini
sangat sederhana.

95
00:05:05,120 --> 00:05:08,310
Ini adalah C, merupakan
ciphertext-nya.

96
00:05:08,310 --> 00:05:12,880
Jadi ada sedikit terminologi
di sini, cipher text.

97
00:05:12,880 --> 00:05:16,175
m adalah plain text
atau pesannya (message)

98
00:05:19,100 --> 00:05:21,240
Dan plain text artinya
Anda dapat membacanya.

99
00:05:21,240 --> 00:05:23,870
Cipher text artinya
itu diacak.

100
00:05:23,870 --> 00:05:29,130
K adalah, tentu saja,
kunci rahasia di atas sini.

101
00:05:29,130 --> 00:05:31,130
Dan e ini adalah
fungsi enkripsi.

102
00:05:37,680 --> 00:05:40,680
Sekarang, di kriptografi
kunci simetris,

103
00:05:40,680 --> 00:05:44,450
pada dasarnya kebutuhannya
adalah Anda

104
00:05:44,450 --> 00:05:49,390
harus bisa mendapatkan kembali
plain text dari cipher

105
00:05:49,390 --> 00:05:54,690
teks jika diketahui fungsi dekripsi
yang publik dan pengetahuan

106
00:05:54,690 --> 00:05:55,930
akan kunci rahasia.

107
00:05:55,930 --> 00:05:58,110
Dan ini harusnya merupakan
operasi yang sederhana,

108
00:05:58,110 --> 00:05:58,780
bukan?

109
00:05:58,780 --> 00:06:04,640
Jadi ngomong-ngomong e dari k m,
ini komputasi dengan waktu polinomial

110
00:06:04,640 --> 00:06:06,410
Ini bukan waktu konstan.

111
00:06:06,410 --> 00:06:08,140
Biasanya waktu linier.

112
00:06:08,140 --> 00:06:11,980
Dan Anda tidak ingin itu
menjadi kuadratik,

113
00:06:11,980 --> 00:06:15,340
karena Anda ingin melakukannya
dengan (sangat?) cepat, mengalir (streaming).

114
00:06:15,340 --> 00:06:18,000
Anda perlu mengirimkan
aliran pesan,

115
00:06:18,000 --> 00:06:21,180
bergiga-gigabyte mungkin,
semuanya terenkripsi.

116
00:06:21,180 --> 00:06:22,560
Dan ini sebenarnya
yang terjadi

117
00:06:22,560 --> 00:06:24,700
Saat Anda menerima sesuatu
dari satelit Anda

118
00:06:24,700 --> 00:06:26,380
dan Anda mengunduh film.

119
00:06:26,380 --> 00:06:28,350
itu yang sebenarnya terjadi.

120
00:06:28,350 --> 00:06:31,670
Itu adalah enkripsi kunci
simetris dari data yang banyak.

121
00:06:31,670 --> 00:06:36,554
Jadi ke belakang menjadi dk c.

122
00:06:36,554 --> 00:06:38,720
Dan satu-satunya perbedaan
di sini adalah ini, selain itu

123
00:06:38,720 --> 00:06:39,960
tetap sama.

124
00:06:39,960 --> 00:06:41,440
Ini adalah sistem dekripsi kita.

125
00:06:44,980 --> 00:06:46,690
Baiklah.

126
00:06:46,690 --> 00:06:50,630
Jadi itu adalah enkripsi
simetris.

127
00:06:50,630 --> 00:06:54,100
Dan ada kebutuhan untuk
bisa dibalik di sini.

128
00:06:54,100 --> 00:06:57,590
Jadi itu sangat berbeda
dengan hash satu arah

129
00:06:57,590 --> 00:06:59,340
yang kita bicarakan sebelumnya.

130
00:06:59,340 --> 00:07:06,800
Karena di sini, walaupun Anda
ingin berpindah dari c ke m dengan sulit,

131
00:07:06,800 --> 00:07:11,990
itu hanya sulit jika sang
penyerang tidak tahu k.

132
00:07:11,990 --> 00:07:14,490
Jika siapapun tahu k,
itu harusnya mudah.

133
00:07:14,490 --> 00:07:18,030
Sebenarnya, e dan d
nantinya akan

134
00:07:18,030 --> 00:07:21,770
secara virtual identik
dalam hal kompleksitas

135
00:07:21,770 --> 00:07:23,850
dan terkadang implementasinya juga.

136
00:07:23,850 --> 00:07:27,300
Itu hanya tentang Anda menjalankannya
terbalik, dan Anda mendapatkan

137
00:07:27,300 --> 00:07:29,040
kembali apa yang Anda enkripsi sebelumnya.

138
00:07:29,040 --> 00:07:30,960
Begitu cara berpikirnya.

139
00:07:30,960 --> 00:07:37,340
Jadi sebenarnya yang terjadi adalah
Anda memerlukan operasi yang bisa dibalik

140
00:07:37,340 --> 00:07:45,030
Untuk membangun e atau d,
di mana merupakan fungsi

141
00:07:45,030 --> 00:07:46,840
enkripsi dan dekripsi.

142
00:07:46,840 --> 00:07:50,440
Jadi permutasi, contohnya,
bisa dibalik.

143
00:07:50,440 --> 00:07:52,520
Anda dapat selalu mengambil
sesuatu dan mem-permutasinya,

144
00:07:52,520 --> 00:07:54,660
dan Anda bisa berjalan mundur.

145
00:07:54,660 --> 00:07:57,390
Jadi Anda bisa melakukan
hal seperti itu.

146
00:07:57,390 --> 00:08:01,530
Dan permutasi, kebalikannya,
tampak seperti itu.

147
00:08:01,530 --> 00:08:03,800
Apa maksudnya ini?

148
00:08:03,800 --> 00:08:07,350
Ini adalah fakta bahwa
saya punya 3 bit di sini.

149
00:08:07,350 --> 00:08:12,300
Dan mereka berubah menjadi
3 bit di sana.

150
00:08:12,300 --> 00:08:16,265
Dan jelas sekali, jika saya
membalik permutasinya

151
00:08:16,265 --> 00:08:19,220
dan jika saya menambahkan hal
sederhana seperti itu abc

152
00:08:19,220 --> 00:08:21,190
dan saya akan
mengonversinya menjadi cba,

153
00:08:21,190 --> 00:08:23,830
maka cba dapat
kembali ke abc

154
00:08:23,830 --> 00:08:25,060
permutasi terbalik.

155
00:08:25,060 --> 00:08:27,660
Jadi jelas saja, ini adalah
operasi yang dapat dikembalikan.

156
00:08:27,660 --> 00:08:30,330
Tetapi ada operasi-operasi lain
yang dapat dikembalikan juga.

157
00:08:30,330 --> 00:08:35,840
Plus dapat dibalik
dengan negasi.

158
00:08:35,840 --> 00:08:39,580
Dan XOR bisa dibalik
dengan XOR juga.

159
00:08:39,580 --> 00:08:45,905
Karena jika Anda melakukan A 
XOR B, maka Anda mendapatkan C.

160
00:08:45,905 --> 00:08:50,590
Dan bayangkan jika anda melakukan XOR B
lagi, Anda mendapatkan kembali A.

161
00:08:50,590 --> 00:08:52,230
Itulah yang saya maksud dengan pembalikan.

162
00:08:52,230 --> 00:08:56,240
Karena pada dasarnya Anda memiliki A
XOR A akan dibatalkan.

163
00:08:56,240 --> 00:09:00,780
Jadi itu seperti XOR B
XOR B

164
00:09:00,780 --> 00:09:04,330
lagi akan memberikan A.

165
00:09:04,330 --> 00:09:09,110
Jadi jika Anda melihat pada AES, 
contohnya, atau Advance

166
00:09:09,110 --> 00:09:12,430
Encryption Standard (AES), adalah 
benar-benar hanya empat baris kode,

167
00:09:12,430 --> 00:09:14,380
mungkin hanya delapan baris code.

168
00:09:14,380 --> 00:09:18,520
Tapi ini banyak sekali
digunakan, sudah ada

169
00:09:18,520 --> 00:09:22,670
sejak lama, enkripsi 
kunci simetri yang

170
00:09:22,670 --> 00:09:27,020
berjalan di mode 128 bit dan
juga berjalan di mode 256bit.

171
00:09:27,020 --> 00:09:30,410
dan itu, seperti yang saya 
katakakn, beberapa baris kode.

172
00:09:30,410 --> 00:09:34,370
dan Anda akan melihat operasi 
seperti ini, yaitu permutasi.

173
00:09:34,370 --> 00:09:37,720
dan anda akan melihat simbol topi (^)
jika anda melihat program berbahasa C, di mana

174
00:09:37,720 --> 00:09:39,140
adalah XOR.

175
00:09:39,140 --> 00:09:42,260
Dan anda bisa melihat 
enkripsi dan deskripsi

176
00:09:42,260 --> 00:09:43,840
merupakan hal yang identik di dalam implementasinya.

177
00:09:43,840 --> 00:09:46,500
Anda hanya akan menjalankannya satu arah,
dan Anda menjalankannya lagi.

178
00:09:46,500 --> 00:09:49,040
dan Anda mendapatkan hasilnya.
Karena permutasi ini

179
00:09:49,040 --> 00:09:50,060
bisa di dikembalikan.

180
00:09:50,060 --> 00:09:52,080
dan topi juga bisa di kembalikan (bolak balik)

181
00:09:52,080 --> 00:09:54,880
Dan itu semua bilangan bulat bertanda
(positif & negatif), jadi Anda

182
00:09:54,880 --> 00:09:55,940
hanya menjumlahkan mereka.

183
00:09:55,940 --> 00:09:58,220
Dan ini hanya
komplemen aritmatika,

184
00:09:58,220 --> 00:10:00,140
jadi akan terlihat sama juga.

185
00:10:00,140 --> 00:10:02,440
Jadi saya menyarankan Anda untuk
melihat lebih dalam AES.

186
00:10:02,440 --> 00:10:04,500
Saya tidak akan menghabiskan
banyak waktu untuk itu.

187
00:10:04,500 --> 00:10:09,390
Kunci dari ide ini terletak pada
simetri dan kemampuan untuk dibalik (reversibility).

188
00:10:09,390 --> 00:10:10,944
Kita meninggalkan
hal tersebut.

189
00:10:10,944 --> 00:10:12,360
Jelas, kita tidak
berbicara tentang hal tersebut

190
00:10:12,360 --> 00:10:14,720
saat kita berbicara tentang fungsi hash
satu arah, dan sebagainya.

191
00:10:14,720 --> 00:10:18,500
Itu merupakan sebuah situasi yang berbeda
di mana kita tidak memiliki kerahasiaan.

192
00:10:18,500 --> 00:10:21,770
Tapi di sini, kita menginginkan simetri.

193
00:10:21,770 --> 00:10:23,560
Pertanyaan besar
Anda akan tanyakan

194
00:10:23,560 --> 00:10:26,590
dan Anda baiknya bertanya pada diri sendiri
saat Anda melihat ini, Anda berkata,

195
00:10:26,590 --> 00:10:27,470
Oke bagus.

196
00:10:27,470 --> 00:10:30,810
Saya dapat membangun algoritme
enkripsi kunci simetri

197
00:10:30,810 --> 00:10:32,790
Mereka sebenarnya, menurut
saya, lebih mudah

198
00:10:32,790 --> 00:10:36,020
untuk dilakukan daripada membangun
fungsi hash, yang

199
00:10:36,020 --> 00:10:39,560
mempunyai banyak sekali
properti-properti yang menarik

200
00:10:39,560 --> 00:10:43,260
dan sulit untuk mendapatkan properti
seperti (collision) resistance

201
00:10:43,260 --> 00:10:48,470
tetapi pertanyaanya adalah
bagaimana cara Alice dan Bob

202
00:10:48,470 --> 00:10:50,950
berbagi kunci rahasia, k?

203
00:10:50,950 --> 00:10:52,040
Jadi Anda membutuhkannya.

204
00:10:52,040 --> 00:10:54,770
Anda membutuhkan angka 128-bit 
ini agar 

205
00:10:54,770 --> 00:10:58,750
terdapat sebuah saluran,
saluran aman, di mana Alice

206
00:10:58,750 --> 00:11:02,570
dapat berkomunikasi dengan Bob
dan sebaliknya.

207
00:11:02,570 --> 00:11:05,320
Jadi sekarang Anda dapat berkata
Alice mengirimkan Bob sebuah surat.

208
00:11:05,320 --> 00:11:09,000
Tetapi Anda tahu, Mal dapat
mecegat pesan tersebut.

209
00:11:09,000 --> 00:11:12,930
dan yang lebih buruk lagi, adalah 
melihat surat tersebut,

210
00:11:12,930 --> 00:11:15,290
mengirimkan pesan
yang sama, yang

211
00:11:15,290 --> 00:11:20,920
adalah hal terbaik untuk
nya, dan Alice dan Bob

212
00:11:20,920 --> 00:11:22,750
berpikir bahwa mereka telah
memiliki saluran aman.

213
00:11:22,750 --> 00:11:25,360
Hal tersebut adalah semacam
skenario terbaik untuk mal, benar?

214
00:11:25,360 --> 00:11:29,320
Jadi Anda bisa memiliki
mal di tengah sini.

215
00:11:29,320 --> 00:11:33,050
Dan anda harus khawatir
tentang hal seperti itu.

216
00:11:33,050 --> 00:11:39,050
Jadi pertukaran kunci, mari kita lanjutkan 
pembicaraan tentang pertukaran kunci.

217
00:11:46,445 --> 00:12:00,060
Dan bagaimana kunci 
rahasia k dapat dibagikan?

218
00:12:00,060 --> 00:12:03,980
Anda tidak bisa meletakkan
ini di situs web, bukan?

219
00:12:03,980 --> 00:12:06,750
Jadi seharusnya, 
berbagi

220
00:12:06,750 --> 00:12:12,200
adalah sesuatu yang harus
aman dalam artian

221
00:12:12,200 --> 00:12:14,730
bahwa tidak boleh
ada penyadap.

222
00:12:14,730 --> 00:12:20,195
Ini adalah contoh favorit saya
dari teka-teki yang kebanyakan dari Anda

223
00:12:20,195 --> 00:12:23,170
mungkin pernah mendengarnya.

224
00:12:23,170 --> 00:12:26,800
Tapi bagi Anda yang belum,
ini sangat keren.

225
00:12:26,800 --> 00:12:32,700
Dan di antara Anda yang sudah, ini
masih terlihat sangat bagus dan bermakna

226
00:12:32,700 --> 00:12:33,790
untuk diingat.

227
00:12:33,790 --> 00:12:36,300
Dan sebenarnya
sesuatu yang Anda mungkin

228
00:12:36,300 --> 00:12:38,250
belum pernah memikirkannya
secara mendalam bahkan jika Anda pernah

229
00:12:38,250 --> 00:12:39,450
mendengar teka-teki ini.

230
00:12:39,450 --> 00:12:42,480
Itu adalah asumsi
matematika yang dibuat

231
00:12:42,480 --> 00:12:44,080
di dalam solusi untuk teka-teki ini.

232
00:12:44,080 --> 00:12:45,930
Itu akan menarik bagi Anda.

233
00:12:45,930 --> 00:12:47,980
Tetapi teka-teki itu adalah
teka-teki tentang bajak laut.

234
00:12:47,980 --> 00:12:50,050
Jadi Anda punya Alice dan Bob.

235
00:12:50,050 --> 00:12:51,900
Sebut saja itu
Karibia, karena itu adalah

236
00:12:51,900 --> 00:12:53,740
lautan favorit saya.

237
00:12:53,740 --> 00:12:56,896
Dan Alice dan Bob berada di
dua pulau yang berbeda.

238
00:12:56,896 --> 00:12:59,020
Dan kita semua tahu ada beberapa
bajak laut di Karibia,

239
00:12:59,020 --> 00:13:01,600
benar?

240
00:13:01,600 --> 00:13:06,140
Jadi Alice dan Bob ingin
berkomunikasi satu sama lain.

241
00:13:06,140 --> 00:13:12,090
Dan yang dimiliki Alice adalah sekumpulan
kotak dan gembok serta kunci.

242
00:13:14,930 --> 00:13:19,150
Dia memiliki kunci untuk
gembok milik dia saja

243
00:13:19,150 --> 00:13:22,980
dan sama halnya dengan Bob.

244
00:13:22,980 --> 00:13:30,460
Jadi Bob memiliki kotak, gembok,
kunci untuk gembok miliknya

245
00:13:30,460 --> 00:13:32,360
sehingga dia dapat menyimpan dalam kotak miliknya.

246
00:13:32,360 --> 00:13:36,690
Dan dalam kasus ini, Alice ingin
mengirim pesan kepada Bob.

247
00:13:36,690 --> 00:13:39,110
Dan Alice ingin 
bertukar kunci dengan Bob,

248
00:13:39,110 --> 00:13:43,770
sehingga mereka akhirnya dapat
berkomunikasi secara aman

249
00:13:43,770 --> 00:13:47,050
tanpa peduli bajak laut atau
siapapun mendengarnya.

250
00:13:47,050 --> 00:13:49,852
Jadi masalahnya di sini adalah,
tentu saja, hanya jika Anda ingin

251
00:13:49,852 --> 00:13:52,310
mengirim sebuah pesan pada perahu-- jadi
para bajak laut sebenarnya baik,

252
00:13:52,310 --> 00:13:58,260
dalam satu hal, mereka akan
mengirimkan pesan.

253
00:13:58,260 --> 00:14:01,730
Tetapi mereka akan penasaran, benar?

254
00:14:01,730 --> 00:14:03,000
Jadi mereka akan sangat pensaran.

255
00:14:03,000 --> 00:14:04,654
Dan mereka akan membuka kotak tersebut.

256
00:14:04,654 --> 00:14:06,820
Dan jadi itu seharusnya adalah
perahu, ngomong-ngomong, bukan 

257
00:14:06,820 --> 00:14:10,880
suatu kotak, sedikit tiang kapal disana

258
00:14:10,880 --> 00:14:14,150
Jadi saya bukan seorang pelaut.

259
00:14:14,150 --> 00:14:18,830
Tetapi, kalian memiliki kotak-kotak ini 
yang akan diantar.

260
00:14:18,830 --> 00:14:20,740
dan ini adalah kesepakatannya.

261
00:14:20,740 --> 00:14:23,376
jika ada satu kotak yang terbuka, 
bajak laut yang akan membuka kotaknya.

262
00:14:23,376 --> 00:14:25,584
dan jika ada pesan di dalam kotak 
itu, mereka mungkin akan membacanya,

263
00:14:25,584 --> 00:14:26,760
atau mereka mungkin membuangnya.

264
00:14:26,760 --> 00:14:32,550
Jadi jelas sekali, sebuah 
kunci rahasia bisa ditukar

265
00:14:32,550 --> 00:14:36,150
hanya dengan hanya meletakkan kotak 
yang didalamnya ada pesan

266
00:14:36,150 --> 00:14:38,350
jika anda tidak menguncinya.

267
00:14:38,350 --> 00:14:43,220
Mereka tidak akan bisa 
membukanya, tidak bisa menyentuh,

268
00:14:43,220 --> 00:14:47,040
dan mereka akan 
mengirimkan kotak yang terkunci.

269
00:14:47,040 --> 00:14:51,390
Tetapi jika mereka melihat 
sebuah kunci, mereka akan menyimpannya.

270
00:14:51,390 --> 00:14:53,435
Jika mereka pernah melihat 
semacam sebuah kunci di kapal,

271
00:14:53,435 --> 00:14:54,810
mereka akan langsung 
mengambilnya dan menyimpannya.

272
00:14:54,810 --> 00:14:57,018
Dan kemudian pada waktu berikutnya, 
mereka melihat sebuah kotak terkunci,

273
00:14:57,018 --> 00:15:00,140
mereka akan memasukkan kunci 
dan mencoba membukanya.

274
00:15:00,140 --> 00:15:01,970
Baiklah.

275
00:15:01,970 --> 00:15:06,340
Jadi bagaimana Alice dan Bob 
dengan aman bertukar rahasia

276
00:15:06,340 --> 00:15:09,600
di mana keamanan didasarkan 
pada gagasan pembajakan ini,

277
00:15:09,600 --> 00:15:16,980
Saya kira, dengan bajak laut
memiliki sejumlah kemampuan

278
00:15:16,980 --> 00:15:20,610
dalam hal menyimpan kunci,
dan membuka kunci,

279
00:15:20,610 --> 00:15:23,460
tetapi mereka tidak akan 
menyentuh kotak yang terkunci?

280
00:15:23,460 --> 00:15:24,635
Baiklah.

281
00:15:24,635 --> 00:15:25,510
Jadi itulah teka-tekinya.

282
00:15:25,510 --> 00:15:27,790
Berapa banyak dari kalian yang sudah mendengar
tentang teka-teki ini sebelumnya?

283
00:15:27,790 --> 00:15:30,090
Jadi Anda semua tetap diam.

284
00:15:30,090 --> 00:15:34,350
Seseorang yang belum pernah mendengar
tentang teka-teki ini sebelumnya,

285
00:15:34,350 --> 00:15:39,770
coba pikirkan sejenak dan
lihat apakah ada sebuah solusi terpikirkan oleh Anda

286
00:15:39,770 --> 00:15:43,490
Dalam hal bolak-balik--
jadi itulah petunjuknya,

287
00:15:43,490 --> 00:15:47,980
bolak-balik-- dan
dapat secara aman menukarkan

288
00:15:47,980 --> 00:15:51,660
sebuah pesan, yang bisa berupa
kunci rahasia 128-bit tertulis

289
00:15:51,660 --> 00:15:55,060
pada catatan kecil
antara Alice dan Bob.

290
00:15:55,060 --> 00:15:55,560
Ya?

291
00:15:55,560 --> 00:15:56,578
Di belakang sana.

292
00:15:56,578 --> 00:16:00,780
AUDIENS: Apakah mereka diizinkan
untuk melewatkan kunci-kuncinya sedemikian--

293
00:16:00,780 --> 00:16:02,530
SRINIVAS DEVADAS: Jadi
jika Anda lihat itu terkunci,

294
00:16:02,530 --> 00:16:04,510
Mereka akan membuang
gemboknya juga.

295
00:16:04,510 --> 00:16:08,370
Jika gemboknya berada
pada kotak, tentu saja,

296
00:16:08,370 --> 00:16:10,340
mereka akan mengirim kotak itu.

297
00:16:10,340 --> 00:16:12,610
Tetapi jika kunci berada
di luar kotak itu,

298
00:16:12,610 --> 00:16:13,960
maka mereka akan menyimpan kuncinya.

299
00:16:21,990 --> 00:16:24,270
Tidak-- ini adalah teka-teki yang sulit.

300
00:16:24,270 --> 00:16:26,246
Ya?

301
00:16:26,246 --> 00:16:29,107
AUDIENS: Alice dapat mengunci
kotak dan mengirimkannya kepada Bob.

302
00:16:29,107 --> 00:16:30,065
SRINIVAS DEVADAS: Ya.

303
00:16:30,065 --> 00:16:34,572
AUDIENS: Dan kemudian Bob
juga dapat mengunci kotaknya.

304
00:16:34,572 --> 00:16:35,900
SRINIVAS DEVADAS: Ya.

305
00:16:35,900 --> 00:16:37,090
Kemudian?

306
00:16:37,090 --> 00:16:40,801
Pada poin itu-- tidak,
Anda berada pada jalur yang tepat.

307
00:16:40,801 --> 00:16:41,300
Lanjutkan.

308
00:16:41,300 --> 00:16:43,740
Lanjutkanlah sedikit lagi.

309
00:16:43,740 --> 00:16:46,492
Naik perahu beberapa lagi
dan kita akan selesai.

310
00:16:46,492 --> 00:16:48,456
Ya

311
00:16:48,456 --> 00:16:52,501
AUDIENS: Kemudian
jika Bob mengirim--

312
00:16:52,501 --> 00:16:54,750
SRINIVAS DEVADAS: Jadi 
sekarang ada dua gembok pada kotak.

313
00:16:54,750 --> 00:16:55,590
AUDIENS: Ya.

314
00:16:55,590 --> 00:16:58,562
SRINIVAS DEVADAS: Dan Bob
memiliki 2 gembok pada kotak.

315
00:16:58,562 --> 00:17:00,020
Dan jadi apa yang Bob
akan lakukan selanjutnya?

316
00:17:00,020 --> 00:17:03,742
Apa hal yang logis 
untuk Bob lakukan selanjutnya?

317
00:17:03,742 --> 00:17:05,089
AUDIENS: Mengirimkan kembali kepada Alice.

318
00:17:05,089 --> 00:17:06,630
SRINIVAS DEVADAS:
Mengirimkan kembali Alice.

319
00:17:06,630 --> 00:17:10,300
Dan sekarang kuncinya berada di dalam.

320
00:17:10,300 --> 00:17:14,170
Alice sekarang melihat dua
gembok pada kotak.

321
00:17:14,170 --> 00:17:16,420
Dan salah satu gembok adalah milik Bob.

322
00:17:16,420 --> 00:17:17,180
Dan yang satunya adalah?

323
00:17:17,180 --> 00:17:18,069
AUDIENS: Miliknya (Alice).

324
00:17:18,069 --> 00:17:18,690
SRINIVAS DEVADAS: itu miliknya.

325
00:17:18,690 --> 00:17:19,380
AUDIENS: Dia bisa membuka kucinya.

326
00:17:19,380 --> 00:17:21,046
SRINIVAS DEVADAS: Ia 
bisa membuka kuncinya

327
00:17:21,046 --> 00:17:23,540
dan mengirimkannya kembali ke Bob.

328
00:17:23,540 --> 00:17:27,650
Dan selama ini, satu-satunya
hal yang hilang di perjalanan

329
00:17:27,650 --> 00:17:29,750
adalah kotak yang terkunci

330
00:17:29,750 --> 00:17:32,050
Tidak ada kunci yang hilang
dalam transit,

331
00:17:32,050 --> 00:17:34,400
apakah mereka ada di dalam
kotak atau dimanapun.

332
00:17:34,400 --> 00:17:38,720
Tapi satu-satunya hal yang
dipindahkan adalah kotak yang terkunci.

333
00:17:38,720 --> 00:17:39,410
Jadi itu bagus.

334
00:17:39,410 --> 00:17:40,550
Anda tepat sekali.

335
00:17:40,550 --> 00:17:45,110
Jadi itu akan memberi Anda sebuah Frisbee.

336
00:17:45,110 --> 00:17:46,930
Ups, maaf.

337
00:17:46,930 --> 00:17:48,710
Kita membutuhkan pertukaran yang aman di sana.

338
00:17:48,710 --> 00:17:50,730
Ya, itu bagus.

339
00:17:50,730 --> 00:17:54,250
Jadi itu sangat tepat.

340
00:17:54,250 --> 00:18:05,610
Untuk merekap, Alice
mengunci kotak dengan KA,

341
00:18:05,610 --> 00:18:09,980
Dan itulah kunci untuk 
gemboknya, mengirimkannya ke Bob.

342
00:18:09,980 --> 00:18:18,320
Bob mengunci kotak dengan
KB, mengirimkannya ke Alice.

343
00:18:18,320 --> 00:18:24,220
Dan Alice membuka--
oh, seharusnya saya katakan

344
00:18:24,220 --> 00:18:27,100
Alice menyimpan pesan di dalam kotak.

345
00:18:32,590 --> 00:18:36,630
Dan pesan itu mempunyai
kunci rahasia di dalamnya.

346
00:18:36,630 --> 00:18:45,840
Alice membuka KA dan
mengirim kotak kepada Bob.

347
00:18:45,840 --> 00:18:56,130
Dan selanjutnya Bob membuka
KB dan membaca pesan.

348
00:18:56,130 --> 00:18:57,470
Jadi itu bagus.

349
00:18:57,470 --> 00:18:59,870
Itu semua bagus.

350
00:18:59,870 --> 00:19:03,480
Mari kita lihat ini
sedikit lebih dalam lagi

351
00:19:03,480 --> 00:19:08,170
dan berpikir tentang ini dari
sudut pandang matematika, bukan

352
00:19:08,170 --> 00:19:09,330
dari sudut pandang fisika.

353
00:19:09,330 --> 00:19:11,990
Anda bisa memikirkan tentang ini
dari sudut pandang fisika juga.

354
00:19:11,990 --> 00:19:18,050
Apa hubungan antara 
penguncian ini, urutan ini,

355
00:19:18,050 --> 00:19:22,550
dalam hal ini sepasang
kunci, yang kita butuhkan di sini

356
00:19:22,550 --> 00:19:25,310
agar secara
fisik masuk akal?

357
00:19:25,310 --> 00:19:25,810
s

358
00:19:25,810 --> 00:19:27,435
Maksud saya, ada 
cara berbeda untuk Anda

359
00:19:27,435 --> 00:19:29,890
menambahkan dua kunci ke kotak.

360
00:19:29,890 --> 00:19:32,120
Ada banyak cara berbeda.

361
00:19:32,120 --> 00:19:37,440
Salah satu caranya adalah memiliki kotak 
yang terkunci jika saya lihat di sini.

362
00:19:37,440 --> 00:19:39,630
Dan itu tidak terbuka, karena 
tutupnya tidak terbuka.

363
00:19:39,630 --> 00:19:41,310
Saya punya koper seperti itu.

364
00:19:41,310 --> 00:19:43,549
Dan mungkin ada
tempat lain di sini

365
00:19:43,549 --> 00:19:44,465
yang terlihat seperti itu juga.

366
00:19:47,030 --> 00:19:49,090
Jadi itu bisa menjadi salah satu cara.

367
00:19:49,090 --> 00:19:51,800
Jadi, apa cara lain
untuk memiliki dua kunci?

368
00:19:51,800 --> 00:19:52,300
Ya

369
00:19:52,300 --> 00:19:53,680
AUDIENS: Meletakkan
sebuah kotak di dalam kotak.

370
00:19:53,680 --> 00:19:54,860
SRINIVAS DEVADAS: Ya,
meletakkan sebuah kotak dalam kotak.

371
00:19:54,860 --> 00:19:56,090
Itu bagus.

372
00:19:56,090 --> 00:20:02,270
Jadi jika Anda meletakkan sebuah kotak di dalam
sebuah kotak, lalu apakah ini berfungsi?

373
00:20:02,270 --> 00:20:04,090
Itu tidak berhasil, bukan?

374
00:20:04,090 --> 00:20:06,350
Jadi kunci berlapis
sebenarnya tidak berhasil.

375
00:20:06,350 --> 00:20:17,680
Karena apa yang terjadi di sini adalah
bahwa KA disimpan pertama, kemudian KB.

376
00:20:17,680 --> 00:20:22,730
Dan jika, faktanya, Anda punya
KA, dan kemudian KB di luar sana,

377
00:20:22,730 --> 00:20:35,729
maka Anda tidak dapat menghapus
KA tanpa menghapus KB.

378
00:20:35,729 --> 00:20:38,020
Dan ini akan menjadi kasus
di mana Anda memiliki kunci berlapis.

379
00:20:42,180 --> 00:20:44,860
Jadi operasi 
matematika yang kita perlukan

380
00:20:44,860 --> 00:20:48,890
adalah komutatif
di antara gembok-gembok.

381
00:20:48,890 --> 00:20:51,010
Dan gembok-gemboknya perlu berpindah.

382
00:20:51,010 --> 00:20:53,900
Saya ingin meletakkan KA terlebih dahulu.

383
00:20:53,900 --> 00:20:56,320
Seperti yang saya jelaskan, 
realisasi fisik 

384
00:20:56,320 --> 00:20:59,440
secara sederhana adalah koper
dengan dua posisi yang berbeda

385
00:20:59,440 --> 00:21:00,250
untuk dua gembok.

386
00:21:00,250 --> 00:21:03,760
Dan salah satu dari
posisi itu mengunci koper.

387
00:21:03,760 --> 00:21:05,820
Jadi Anda meletakkan KA di sini, KB di sini.

388
00:21:05,820 --> 00:21:08,400
Dan selanjutnya Anda dapat
mengeluarkan KA, benar?

389
00:21:08,400 --> 00:21:10,860
Dan itu tetap terkunci,
karena Anda mempunyai KB.

390
00:21:10,860 --> 00:21:20,130
Jadi sifat komutatif antara
kunci dan dasarnya

391
00:21:20,130 --> 00:21:24,200
kuncinya adalah apa yang dibutuhkan.

392
00:21:27,490 --> 00:21:30,930
Dan sekarang, mari
berpindah dari bajak laut

393
00:21:30,930 --> 00:21:33,930
dan masuk ke dalam
domain kriptografi,

394
00:21:33,930 --> 00:21:36,670
domain matematika murni,
dan lihat

395
00:21:36,670 --> 00:21:38,740
bagaimana ini mengubah
menjadi apa yang disebut

396
00:21:38,740 --> 00:21:43,130
pertukaran kunci Diffie-Hellman,
yang merupakan pertukaran kunci

397
00:21:43,130 --> 00:21:48,720
algoritme atau sebuah protokol yang
dalam kondisi tertentu

398
00:21:48,720 --> 00:21:50,590
memberi Anda persis
apa yang ingin Anda lihat di sini.

399
00:21:50,590 --> 00:21:52,420
Itu memberi Anda sebuah
pertukaran kunci yang aman.

400
00:21:52,420 --> 00:21:55,410
Dan ada satu masalah
yang berhubungan dengan itu,

401
00:21:55,410 --> 00:21:58,020
dan masalah itu akan menjadi jelas
ketika kita menulis itu di sini,

402
00:21:58,020 --> 00:21:59,720
yang akan kita bahas kembali.

403
00:21:59,720 --> 00:22:02,430
Tetapi pertukaran kunci
Diffie-Hellman memberi asumsi bahwa Anda

404
00:22:02,430 --> 00:22:04,420
memiliki gembok komutatif.

405
00:22:04,420 --> 00:22:09,930
Dan inilah bagaimana cara kerjanya.

406
00:22:09,930 --> 00:22:16,040
Anda akan melihat apa yang terganti
ketika saya memberi Anda persamaan

407
00:22:16,040 --> 00:22:18,760
yang terhubung dengan
pertukaran kunci Diffie-Hellman.

408
00:22:18,760 --> 00:22:25,100
Dan hal ini juga
dijelaskan pada tahun 70-an.

409
00:22:25,100 --> 00:22:29,630
Jadi apa yang akan kita lakukan adalah
kita akan bekerja pada ruang

410
00:22:29,630 --> 00:22:33,120
terbatas Fp*

411
00:22:33,120 --> 00:22:36,450
Dan ruang berhingga 
berarti kita

412
00:22:36,450 --> 00:22:41,820
akan melakukan mod
p, di mana p adalah bilangan prima.

413
00:22:41,820 --> 00:22:45,060
Dan bintang berarti kita
hanya akan melihat

414
00:22:45,060 --> 00:22:48,930
elemen yang bisa dibalik saja.

415
00:22:48,930 --> 00:22:52,449
Jadi kita membuang
elemen yang tidak bisa dibalik.

416
00:22:52,449 --> 00:22:54,240
Hal-hal ini 
tidak terlalu penting.

417
00:22:57,470 --> 00:22:59,560
Dan jadi kita akan buang 0.

418
00:22:59,560 --> 00:23:03,480
Dan kita akan melihat 
1, 2, hingga p dikurangi 1.

419
00:23:03,480 --> 00:23:05,330
Jadi semua angka 
yang Anda lihat akan menjadi

420
00:23:05,330 --> 00:23:07,690
1 sampai p minus 1.

421
00:23:07,690 --> 00:23:14,440
Sekarang, apa analogi 
dari semua protokol ini

422
00:23:14,440 --> 00:23:20,120
yang dioperasikan atau 
dijalankan oleh Alice dan Bob,

423
00:23:20,120 --> 00:23:23,070
dalam teka-teki bajak laut kita?

424
00:23:23,070 --> 00:23:27,070
Apa analoginya dalam
domain matematika

425
00:23:27,070 --> 00:23:29,060
atau dalam domain ruang berhingga?

426
00:23:29,060 --> 00:23:31,100
Jadi, inilah yang terjadi.

427
00:23:31,100 --> 00:23:39,691
Alice akan
memilih a secara acak.

428
00:23:43,128 --> 00:23:45,450
Dan kita akan
mengasumsikan g adalah publik.

429
00:23:45,450 --> 00:23:51,880
Jadi dia hanya meneriakkannya
kepada-- Alice

430
00:23:51,880 --> 00:23:54,950
dapat melihat Bob dari rumahnya.

431
00:23:54,950 --> 00:23:58,069
Jadi dia meneriakkan
g dan meneriakkan p.

432
00:23:58,069 --> 00:23:58,860
Mereka semua publik.

433
00:23:58,860 --> 00:24:02,680
Dia tidak peduli jika
bajak laut dapat mendengar ini.

434
00:24:02,680 --> 00:24:06,440
Dan Alice akan
memilih a, yang merupakan acak,

435
00:24:06,440 --> 00:24:11,810
dan menghitung g dari a.

436
00:24:11,810 --> 00:24:15,470
Dan ini dalam
ruang berhingga, G kapital.

437
00:24:15,470 --> 00:24:17,310
Jadi Anda akan melakukan mod (sisa pembagian) Anda.

438
00:24:17,310 --> 00:24:23,550
Dan Alice hanya akan mengirim
g dari a ke Bob.

439
00:24:23,550 --> 00:24:37,540
Sekarang, apa yang Bob lakukan adalah memilih
b dan menghitung g pangkat b

440
00:24:37,540 --> 00:24:40,490
dan mengirimkannya.

441
00:24:40,490 --> 00:24:42,950
Jadi g pangkat a 
sedang dikirim. g

442
00:24:42,950 --> 00:24:45,600
pangkat b sedang dikirim, 
dikirim kepada Alice.

443
00:24:45,600 --> 00:24:49,160
Jadi Alice mendapat g pangkat b.

444
00:24:49,160 --> 00:24:53,880
Dan hal penting
di sini adalah Alice

445
00:24:53,880 --> 00:25:02,880
dapat menghitung g pangkat b pangkat
a, karena Alice mengetahui a.

446
00:25:02,880 --> 00:25:05,030
Semua ini akan di-mod dengan p.

447
00:25:05,030 --> 00:25:08,200
Dan kita akan menyebutnya
K. Dan faktanya

448
00:25:08,200 --> 00:25:14,210
bahwa perhitungan exponensial
bersifat komutatif, Bob

449
00:25:14,210 --> 00:25:20,810
menghitung g pangkat a
pangkat b, karena Bob

450
00:25:20,810 --> 00:25:25,727
mengetahui b, yang sebenarnya
adalah K-- Saya harus mengatakan mod

451
00:25:25,727 --> 00:25:28,827
p disini.

452
00:25:28,827 --> 00:25:29,660
Semua adalah mod p.

453
00:25:33,430 --> 00:25:34,920
Jadi seperti itu.

454
00:25:34,920 --> 00:25:38,040
Itu adalah pertukaran kunci
Diffie-Hellman.

455
00:25:38,040 --> 00:25:41,690
Anda sekarang telah membuat
sebuah rahasia bersama

456
00:25:41,690 --> 00:25:46,110
yang berdasarkan pada sifat komutatif
dari eksponensial.

457
00:25:46,110 --> 00:25:49,840
Dan bagian yang 
masih hilang di sini

458
00:25:49,840 --> 00:25:55,032
sehubungan dengan analoginya
adalah fakta bahwa g dari a

459
00:25:55,032 --> 00:25:57,760
pada dasarnya adalah kotak yang terkunci.

460
00:25:57,760 --> 00:26:01,690
Jadi yang disembunyikan g dari a adalah a.

461
00:26:01,690 --> 00:26:05,160
Karena Anda ingin a tersembunyi
di sini dan begitu pula dengan g

462
00:26:05,160 --> 00:26:05,660
dari b.

463
00:26:05,660 --> 00:26:07,080
B perlu disembunyikan.

464
00:26:07,080 --> 00:26:11,700
Jadi masalah yang dimiliki
para perompak adalah mereka

465
00:26:11,700 --> 00:26:14,420
tidak bisa membuka kotak itu.

466
00:26:14,420 --> 00:26:19,170
Masalahnya adalah si orang jahat,
sebut saja mereka mal, adalah

467
00:26:19,170 --> 00:26:26,630
bahwa ia harus mencari invers dari g 
dari a untuk menemukan a.

468
00:26:26,630 --> 00:26:30,870
Dan dalam ruang
berhingga ini,

469
00:26:30,870 --> 00:26:34,990
dan banyak ruang berhingga lainnya, 
Anda dapat menganggap ini

470
00:26:34,990 --> 00:26:37,370
sebagai apa yang disebut 
masalah logaritma diskrit.

471
00:26:37,370 --> 00:26:38,870
Jadi, jika Anda tidak 
tahu cara menghitung

472
00:26:38,870 --> 00:26:41,099
logaritma di domain 
berkelanjutan itu.

473
00:26:41,099 --> 00:26:41,890
Dan ada tabel.

474
00:26:41,890 --> 00:26:43,720
Dan itu cukup mudah dilakukan.

475
00:26:43,720 --> 00:26:45,740
Tapi ini yang kita sebut 
masalah logaritma diskrit

476
00:26:45,740 --> 00:26:48,400
karena kita berada 
di ruang berhingga.

477
00:26:48,400 --> 00:26:50,980
Dan kita tentu menginginkan 
bilangan bulat. A merupakan bilangan bulat.

478
00:26:50,980 --> 00:26:54,800
Jadi kita perlu menemukan
apa nilai bilangan bulat tersebut.

479
00:26:54,800 --> 00:26:56,800
Karena kita melakukan 
mod pada nilai p, dan lainnya,

480
00:26:56,800 --> 00:26:59,490
dan p biasanya 
merupakan nilai yang besar

481
00:26:59,490 --> 00:27:02,650
dan itu sebenarnya merupakan 
masalah komputasional yang sulit

482
00:27:02,650 --> 00:27:05,520
untuk melakukan logaritma diskrit.

483
00:27:05,520 --> 00:27:10,820
Jadi, saat anda melihat g dari a,
Anda tahu g, anda tahu p

484
00:27:10,820 --> 00:27:15,710
tapi mencoba untuk mengetahui 
nilai apa yang menghasilkan g dari a

485
00:27:15,710 --> 00:27:16,920
merupakan masalah yang sulit.

486
00:27:16,920 --> 00:27:19,010
Dan orang-orang telah melihat 
ini selama 30, 40 tahun

487
00:27:19,010 --> 00:27:21,929
dan tidak ada algoritme
yang cukup baik untuk menyelesaikan

488
00:27:21,929 --> 00:27:23,720
masalah ini, pastinya
bukan sesuatu yang

489
00:27:23,720 --> 00:27:25,440
dapat diselesaikan dalam waktu polinomial.

490
00:27:25,440 --> 00:27:27,550
Mereka semua seperti 
subeksponensial.

491
00:27:27,550 --> 00:27:32,070
Dan Anda bisa membuat angka
yang cukup besar seperti g dari a

492
00:27:32,070 --> 00:27:37,270
itu aman dalam hal dia
tidak memberi tahu isi nilai a.

493
00:27:37,270 --> 00:27:43,260
Jadi itulah intinya di sini
yang dimiliki Diffie dan Hellman,

494
00:27:43,260 --> 00:27:55,020
yang intinya menyimpulkan bahwa
masalah logaritma diskrit sulit.

495
00:27:55,020 --> 00:27:59,910
dan secara sederhana artinya
diberikan g dari a,

496
00:27:59,910 --> 00:28:03,160
masalah logaritma
diskrit adalah menghitung a.

497
00:28:03,160 --> 00:28:05,950
Dan sama halnya
untuk b, tentu saja.

498
00:28:05,950 --> 00:28:09,300
Ada satu lagi
hal yang Anda ingin

499
00:28:09,300 --> 00:28:11,400
katakan agar lebih tepat
untuk hanya

500
00:28:11,400 --> 00:28:15,490
melingkupi spektrum ini dalam hal
bagaimana ini dapat rusak.

501
00:28:15,490 --> 00:28:19,340
Dan itulah yang disebut
masalah Diffie-Hellman,

502
00:28:19,340 --> 00:28:23,470
untuk ingin nama yang lebih baik dan
karena ini adalah orang-orang yang

503
00:28:23,470 --> 00:28:25,770
pertama kali menemukannya.

504
00:28:25,770 --> 00:28:27,960
Dan masalah Diffie-Hellman
adalah secara sederhana

505
00:28:27,960 --> 00:28:33,680
diberikan g dari a dan g dari b,
yang merupakan apa yang perompak lihat

506
00:28:33,680 --> 00:28:37,610
dan apa yang si penyerang
mal lihat, kita tidak seharusnya

507
00:28:37,610 --> 00:28:43,400
dapat menghitung g
dari a kali b, yang

508
00:28:43,400 --> 00:28:44,790
tepatnya apa yang kita dapat disini.

509
00:28:44,790 --> 00:28:47,600
g dari a dipangkat b
adalah g dari a kali b.

510
00:28:47,600 --> 00:28:49,680
Jadi diberikan kedua
hal itu, jika ada

511
00:28:49,680 --> 00:28:52,990
sebuah cara menghitung
g dari a kali b

512
00:28:52,990 --> 00:28:55,800
meskipun kemungkinan Anda
belum menemukannya

513
00:28:55,800 --> 00:28:59,340
a dan b tepatnya,
g dari a kali b

514
00:28:59,340 --> 00:29:02,060
hanyalah kunci rahasia yang
Alice dan Bob saling tukarkan.

515
00:29:02,060 --> 00:29:03,620
Jadi Anda adalah host.

516
00:29:03,620 --> 00:29:07,240
Alice dan Bob adalah host
jika mal dapat melakukan ini.

517
00:29:07,240 --> 00:29:09,410
Jadi ada dua
hal yang terjadi di sini.

518
00:29:09,410 --> 00:29:12,540
Anda mau masalah Diffie-Hellman
menjadi sulit.

519
00:29:12,540 --> 00:29:16,500
Dan Anda mau masalah log diskrit
menjadi sulit.

520
00:29:16,500 --> 00:29:20,500
OK Jadi secara umum, ini adalah
bagaimana kriptografi bekerja.

521
00:29:20,500 --> 00:29:22,880
Anda mengatur protokol.

522
00:29:22,880 --> 00:29:26,330
Dan ada beberapa informasi
yang akan terungkap

523
00:29:26,330 --> 00:29:30,280
Anda mau informasi ini
menjadi sulit untuk dibalik

524
00:29:30,280 --> 00:29:32,190
untuk mendapatkan informasi yang krusial.

525
00:29:32,190 --> 00:29:34,890
Itu membutuhkan asumsi 
kompleksitas komputasi

526
00:29:34,890 --> 00:29:36,760
seperti dua hal yang
telah kita buat di sini.

527
00:29:36,760 --> 00:29:39,100
Dan kemudian Anda bisa melanjutkannya.

528
00:29:39,100 --> 00:29:42,060
Sistem Anda akan rusak 
jika asumsi kompleksitas

529
00:29:42,060 --> 00:29:44,010
komputasi Anda salah.

530
00:29:44,010 --> 00:29:46,500
Dan mereka mungkin benar 
untuk waktu tertentu,

531
00:29:46,500 --> 00:29:49,910
misalnya, tahun 1970-an
untuk parameter tertentu.

532
00:29:49,910 --> 00:29:53,120
Tetapi mereka mungkin berakhir 
menjadi asumsi yang salah,

533
00:29:53,120 --> 00:29:57,180
setidaknya untuk parameter tersebut,
di lain waktu,

534
00:29:57,180 --> 00:30:00,160
hanya karena komputer
menjadi lebih cepat.

535
00:30:00,160 --> 00:30:03,110
Ini seperti 2 dipangkatkan 40 
adalah angka yang besar ketika

536
00:30:03,110 --> 00:30:04,320
saya seusia Anda.

537
00:30:04,320 --> 00:30:05,840
Sekarang, tidak seperti apa-apa.

538
00:30:05,840 --> 00:30:08,350
Jadi itu pada dasarnya
bagian dari permainan.

539
00:30:08,350 --> 00:30:12,670
Tetapi sistem yang baik adalah sistem
yang bisa menyesuaikan saat Anda meningkatkan

540
00:30:12,670 --> 00:30:16,470
ukuran parameter dan
sistem dan protokol

541
00:30:16,470 --> 00:30:17,950
tetap sama.

542
00:30:17,950 --> 00:30:22,510
Dan Anda hanya meningkatkan p,
sebagai contoh, dalam kasus ini.

543
00:30:22,510 --> 00:30:24,300
Dan masalah diskrit
yang panjang tetap

544
00:30:24,300 --> 00:30:26,400
sulit untuk komputer modern.

545
00:30:26,400 --> 00:30:29,600
Jadi itu adalah protokol yang baik
dan kriptosistem yang baik yang

546
00:30:29,600 --> 00:30:31,950
tidak lekang oleh
waktu, belum tentu

547
00:30:31,950 --> 00:30:36,850
yang memiliki
parameter tertentu.

548
00:30:36,850 --> 00:30:37,610
Itu sulit dilakukan.

549
00:30:37,610 --> 00:30:40,650
Karena seperti yang saya katakan,
Hukum Moore's dan komputer

550
00:30:40,650 --> 00:30:43,740
telah menjadi sangat
cepat secara eksponensial.

551
00:30:43,740 --> 00:30:45,830
Baiklah.

552
00:30:45,830 --> 00:30:51,350
Dan ada satu maslaah utama
dari protokol Diffie-Hellman

553
00:30:51,350 --> 00:30:54,020
dan solusi dari
teka-teki bajak laut.

554
00:30:54,020 --> 00:30:57,167
Dan jadi apakah seseorang dapat memberitahu
saya-- dan itu dapat hanya

555
00:30:57,167 --> 00:30:59,250
untuk masalah
Diffie-Hellman atau hanya

556
00:30:59,250 --> 00:31:01,130
dalam konteks 
masalah Diffie-Hellman,

557
00:31:01,130 --> 00:31:05,290
tetapi juga dalam konteks
teka-teki bajak laut-- apa asumsi

558
00:31:05,290 --> 00:31:08,690
yang kita buat disini
yang belum disebutkan

559
00:31:08,690 --> 00:31:14,560
sehubungan dengan pertukaran kunci
menjadi benar-benar aman?

560
00:31:14,560 --> 00:31:16,080
Seseorang.

561
00:31:16,080 --> 00:31:17,556
Ya.

562
00:31:17,556 --> 00:31:21,500
AUDIENS: jika saya dapat memotong
pesan dari [tidak terdengar]

563
00:31:21,500 --> 00:31:22,990
sesuatu yang berada di belakang mereka?

564
00:31:22,990 --> 00:31:25,060
SRINIVAS DEVADAS:
Apa artinya?

565
00:31:25,060 --> 00:31:26,820
Bajak laut melihat kotak terkunci.

566
00:31:26,820 --> 00:31:29,650
Jadi langkah pertama dari
protokol, Alice

567
00:31:29,650 --> 00:31:32,470
mengirim pesan
ke dalam kotak terkunci

568
00:31:32,470 --> 00:31:33,740
dengan satu gembok didalamnya.

569
00:31:36,520 --> 00:31:38,120
Anda berada di
jalur yang benar.

570
00:31:38,120 --> 00:31:43,340
Dan apa yang bajak laut dapat lakukan
untuk memecahkan protokol ini?

571
00:31:43,340 --> 00:31:45,250
Kita seperti membuat
asumsi disni.

572
00:31:45,250 --> 00:31:47,955
Dan saya mungkin
mengatakan itu secara eksplisit.

573
00:31:47,955 --> 00:31:48,580
Ya, silakan.

574
00:31:48,580 --> 00:31:50,350
AUDIENS: [TIDAK TERDENGAR] 
buang kotak tersebut.

575
00:31:50,350 --> 00:31:51,230
SRINIVAS DEVADAS: Mereka bisa 
saja membuang kotak tersebut.

576
00:31:51,230 --> 00:31:53,396
Tetapi itu tidak melanggar
protokol keamanan tersebut.

577
00:31:53,396 --> 00:31:56,565
Itu melanggar fungsi
dari protokol tersebut, kan?

578
00:31:56,565 --> 00:31:57,190
Ya, silakan.

579
00:31:57,190 --> 00:31:58,770
AUDIENS: Pasang kunci 
lama mereka pada [TIDAK TERDENGAR].

580
00:31:58,770 --> 00:32:00,561
SRINIVAS DEVADAS: Ah, 
itu sangat benar

581
00:32:00,561 --> 00:32:01,680
simpan kunci mereka sendiri di dalamnya.

582
00:32:01,680 --> 00:32:05,051
Anda tahu, jika mereka mempunyai kunci-- jadi
para pembajak ini tidak punya kunci,

583
00:32:05,051 --> 00:32:05,550
benar kan?

584
00:32:05,550 --> 00:32:06,758
Kita membuat asumsi tersebut.

585
00:32:06,758 --> 00:32:09,330
Jika mereka memiliki 
kunci tersendiri,

586
00:32:09,330 --> 00:32:10,940
jika mereka hanya memiliki
sebuah gembok yang terkunci

587
00:32:10,940 --> 00:32:12,440
dan mereka tidak
memiliki kunci untuk itu,

588
00:32:12,440 --> 00:32:13,898
mereka tidak akan
mampu untuk membuka

589
00:32:13,898 --> 00:32:15,140
keamanan protokol.

590
00:32:15,140 --> 00:32:18,910
Tetapi jika mereka memiliki gembok
dan sebuah kunci untuk gembok itu,

591
00:32:18,910 --> 00:32:22,350
Maka mereka dapat berpura-pura
telah mengirimkan ini kepada Bob.

592
00:32:22,350 --> 00:32:25,040
Dan tidak ada otentikasi
di sini dalam hal Alice

593
00:32:25,040 --> 00:32:27,860
tidak begitu tahu apakah dia
berkomunikasi dengan Bob atau tidak.

594
00:32:27,860 --> 00:32:31,640
Dia bergantung pada bajak laut
untuk mengirimkan kotak-kotak ini.

595
00:32:31,640 --> 00:32:37,480
Jadi jika bajak laut memiliki gembok
dan kunci untuk gembok itu,

596
00:32:37,480 --> 00:32:41,760
maka kita ada dalam situasi
di mana Alice mungkin dapat menukarkan

597
00:32:41,760 --> 00:32:44,370
kunci itu dengan bajak laut.

598
00:32:44,370 --> 00:32:46,520
Dan dia pikir dia
menukarkan itu dengan Bob.

599
00:32:46,520 --> 00:32:50,100
Padahal dia, faktanya,
berkomunikasi dengan bajak laut.

600
00:32:50,100 --> 00:33:01,340
Jadi terdapat serangan
man in the middle,

601
00:33:01,340 --> 00:33:10,190
yang berkaitan dengan
bajak laut memiliki gembok dan kunci

602
00:33:10,190 --> 00:33:11,240
mereka sendiri.

603
00:33:11,240 --> 00:33:15,500
Dan hal itu akan menjadi lebih biasa
di dalam kasus gambar kita di sini.

604
00:33:15,500 --> 00:33:18,460
Karena asumsi bahwa
bajak laut mengetahui matematika,

605
00:33:18,460 --> 00:33:22,020
mereka dapat menghasilkan angka
acak-- dan angka tersebut

606
00:33:22,020 --> 00:33:27,020
bisa merupakan c, contohnya-- dan
hanya mengirim kembali g pangkat c.

607
00:33:27,020 --> 00:33:30,170
Dan seperti yang semua Anda tahu,
mereka sebenarnya dapat

608
00:33:30,170 --> 00:33:34,430
membuat Bob mengirim g
pangkat b kembali,

609
00:33:34,430 --> 00:33:38,940
tetapi mereka akan memotong dan
menggantinya dengan g pangkat c.

610
00:33:38,940 --> 00:33:40,767
Dan mereka tahu apa itu c.

611
00:33:40,767 --> 00:33:42,850
Jadi apa yang terjadi sekarang
adalah Anda dapat [TIDAK TERDENGAR].

612
00:33:42,850 --> 00:33:45,320
Saya tidak akan melihat
seluruh matematikanya di sini.

613
00:33:45,320 --> 00:33:48,130
Tetapi Anda dapat sedikit
melihatnya, saya harap.

614
00:33:48,130 --> 00:33:51,950
Anda akan, jika Anda adalah
Alice, menukar

615
00:33:51,950 --> 00:33:58,030
sebuah kunci rahasia dengan
bajak laut sebagai lawan dari Bob.

616
00:33:58,030 --> 00:34:03,280
Dan cara bagaimana anda mengatur ini
adalah bajak laut sebenarnya

617
00:34:03,280 --> 00:34:06,070
akan masuk kepada situasi
di mana Alice dan Bob berpikir

618
00:34:06,070 --> 00:34:08,980
yang mereka ajak berkomunikasi
satu sama lain dengan cara yang aman,

619
00:34:08,980 --> 00:34:11,510
tetapi bajak laut dapat mendengarkan
semua pesan itu.

620
00:34:11,510 --> 00:34:13,210
Mereka dapat mendekripsi
semua pesan tersebut,

621
00:34:13,210 --> 00:34:16,940
karena mereka mengetahui apa
kunci rahasia mereka, k.

622
00:34:16,940 --> 00:34:17,880
OK.

623
00:34:17,880 --> 00:34:19,730
Dan ingatlah bahwa
kunci rahasia, k,

624
00:34:19,730 --> 00:34:21,219
adalah sesuatu yang
mungkin akan

625
00:34:21,219 --> 00:34:25,239
digunakan dalam sebuah skema
enkripsi kunci simetri akhirnya

626
00:34:25,239 --> 00:34:28,510
untuk mengirim pesan yang sesungguhnya.

627
00:34:28,510 --> 00:34:31,190
Jadi Anda akan memiliki teks terenkripsi
dengan kunci rahasia itu,

628
00:34:31,190 --> 00:34:33,179
huruf K besar, di sana.

629
00:34:33,179 --> 00:34:37,730
Dan jika bajak laut atau mal berhasil
mengetahui apa kunci rahasia, k, itu

630
00:34:37,730 --> 00:34:41,000
melalui serangan man in the middle,
Anda akan mendapat masalah.

631
00:34:41,000 --> 00:34:42,080
Benar?

632
00:34:42,080 --> 00:34:46,139
Jadi serangan orang yang berada 
di tengah adalah sesuatu

633
00:34:46,139 --> 00:34:47,730
yang harus kita khawatirkan.

634
00:34:47,730 --> 00:34:49,440
Apa yang akan kita 
bicarakan selanjutnya

635
00:34:49,440 --> 00:34:53,030
adalah sesuatu yang 
menyelesaikan masalah ini.

636
00:34:53,030 --> 00:34:55,739
Dan mungkin tidak langsung 
terlihat

637
00:34:55,739 --> 00:34:57,200
menangani masalah ini.

638
00:34:57,200 --> 00:34:59,300
Namun pada dasarnya,
yang terjadi di sini

639
00:34:59,300 --> 00:35:04,290
adalah Anda perlu memiliki
otentikasi dengan siapa

640
00:35:04,290 --> 00:35:05,310
Anda berkomunikasi.

641
00:35:05,310 --> 00:35:08,080
Alice entah bagaimana
harus mengotentikasi Bob.

642
00:35:08,080 --> 00:35:10,710
Dan Alice harus
mengetahui bagaimana g

643
00:35:10,710 --> 00:35:14,560
dipangkatkan b yang adalah sesuatu 
yang datang dari Bob.

644
00:35:14,560 --> 00:35:16,780
Itu bukan g pangkat c 
yang berasal dari seseorang

645
00:35:16,780 --> 00:35:18,380
lain di tengah-tengah.

646
00:35:18,380 --> 00:35:21,110
Dan disitulah kriptografi kunci
asimetri dan kunci publik

647
00:35:21,110 --> 00:35:26,700
hadir, di mana Anda mempunyai 
kunci publik tersertifikasi yang terasosiasi

648
00:35:26,700 --> 00:35:29,170
dengan diri Anda sendiri.

649
00:35:29,170 --> 00:35:31,230
Dan mungkin anda membutuhkan
VeriSign atau Anda

650
00:35:31,230 --> 00:35:34,090
membutuhkan DMV, atau Registry of Motor Vehicles
(Register Kendaraan Bermotor),

651
00:35:34,090 --> 00:35:36,150
RMV, untuk melakukan ini untuk Anda.

652
00:35:36,150 --> 00:35:39,020
Tapi Anda membuat sebuah 
kunci publik yang telah tersertifikasi,

653
00:35:39,020 --> 00:35:41,430
yang berhubungan 
dengan identitas Anda.

654
00:35:41,430 --> 00:35:42,840
Dan itu publik.

655
00:35:42,840 --> 00:35:45,100
Anda bisa menempatkannya di dalam suatu situs web.

656
00:35:45,100 --> 00:35:47,590
Dan semua orang bisa 
mengakses itu menggunakan HTTPS,

657
00:35:47,590 --> 00:35:50,300
sehingga mereka akan tahu mereka 
menuju tepat ke situs web

658
00:35:50,300 --> 00:35:51,740
yang telah Anda simpan.

659
00:35:51,740 --> 00:35:57,230
Dan hal tersebut memberi Anda cara
untuk mengidentifikasi diri Anda.

660
00:35:57,230 --> 00:35:59,440
Dan jika Anda dapat melakukan
itu, Anda dapat terlindung

661
00:35:59,440 --> 00:36:01,560
dari serangan 
man in the middle menggunakan

662
00:36:01,560 --> 00:36:04,140
kriptografi kunci asimetri.

663
00:36:04,140 --> 00:36:09,390
Jadi itu merupakan bagian akhir
dari teka-teki ini yang 

664
00:36:09,390 --> 00:36:15,470
berkaitan dengan otentikasi
dan pertukaran kunci rahasia dan semuanya

665
00:36:15,470 --> 00:36:16,213
itu.

666
00:36:16,213 --> 00:36:18,337
Setelah kita melakukan itu, Anda akan 
mengetahui fungsi apa

667
00:36:18,337 --> 00:36:19,789
yang kita butuhkan.

668
00:36:19,789 --> 00:36:21,330
Dan sekarang kita akan
berbicara tentang bagaimana

669
00:36:21,330 --> 00:36:22,975
kita bisa membangun sebuah subsistem.

670
00:36:27,520 --> 00:36:28,020
Keren.

671
00:36:28,020 --> 00:36:29,560
Apakah sejauh ini ada pertanyaan?

672
00:36:29,560 --> 00:36:32,930
Baik-baik saja?

673
00:36:32,930 --> 00:36:33,430
Baiklah.

674
00:36:36,060 --> 00:36:40,880
Jadi enkripsi kunci publik, izinkan
saya melakukan sedikit persiapan.

675
00:36:40,880 --> 00:36:44,370
Saya sempat menyinggung sebagian dari ini sebelumnya.

676
00:36:44,370 --> 00:36:48,580
Tetapi untuk memastikan kita memiliki
pemahaman yang sama, apa yang kita punya di sini

677
00:36:48,580 --> 00:36:53,970
adalah kita benar-benar menginginkan
sebuah pesan ditambah kunci publik.

678
00:36:53,970 --> 00:37:02,680
Dan Anda ingin mendapatkan teks terenkripsi
menggunakan operasi ini.

679
00:37:02,680 --> 00:37:05,920
Dan simbol tambah ini bukanlah
penjumlahan aritmetik.

680
00:37:05,920 --> 00:37:08,900
Kita hanyalah menggabungkan
kedua hal ini

681
00:37:08,900 --> 00:37:11,930
menjadi sebuah algoritma, algoritma
enkripsi kunci publik, yang

682
00:37:11,930 --> 00:37:13,500
menghasilkan teks tersandi.

683
00:37:13,500 --> 00:37:14,290
Baiklah.

684
00:37:14,290 --> 00:37:18,910
Dan kunci publik ini, untuk
mengulangi apa yang saya katakan,

685
00:37:18,910 --> 00:37:23,790
akan menjadi jika Alice
yang membuat pesan.

686
00:37:23,790 --> 00:37:26,460
lalu Bob yang mendapatkan
pesan tersandi,

687
00:37:26,460 --> 00:37:30,650
maka ini akan menjadi
kunci publik milik Bob.

688
00:37:30,650 --> 00:37:33,800
Dan fakta bahwa
kunci publik tersebut milik Bob

689
00:37:33,800 --> 00:37:35,420
adalah suatu hal
yang dapat diautentikasi

690
00:37:35,420 --> 00:37:38,370
oleh Alice menggunakan
VeriSign, menggunakan

691
00:37:38,370 --> 00:37:40,574
Daftar Kendaraan Bermotor,
dan sejenisnya.

692
00:37:40,574 --> 00:37:42,490
Itulah yang akan
melindungi dari serangan

693
00:37:42,490 --> 00:37:43,600
man-in-the-middle.

694
00:37:43,600 --> 00:37:44,690
Baik.

695
00:37:44,690 --> 00:37:47,790
Kita tidak akan
banyak bicara tentang bagaimana

696
00:37:47,790 --> 00:37:48,920
Anda bisa mendapatkan sebuah sertifikasi.

697
00:37:48,920 --> 00:37:51,340
Sertifikat MIT Anda
adalah sesuatu yang

698
00:37:51,340 --> 00:37:54,310
sesuai dengan ID MIT Anda.

699
00:37:54,310 --> 00:37:57,330
Dia memiliki informasi, angatan berapakah
Anda, siapa nama Anda.

700
00:37:57,330 --> 00:37:59,470
Dan ketika Anda membangkitkan
sertifikat itu,

701
00:37:59,470 --> 00:38:03,886
Anda mendapatkan sertifikat
otentisitas bahwa Anda adalah Anda.

702
00:38:03,886 --> 00:38:05,260
Dan tentu saja,
Anda memberikan itu

703
00:38:05,260 --> 00:38:07,180
dan Anda menyerahkannya kepada
orang lain, seseorang

704
00:38:07,180 --> 00:38:09,160
dapat juga berpura-pura menjadi Anda.

705
00:38:09,160 --> 00:38:13,860
Tapi itulah yang terjadi
ketika kita membicarakan kunci publik

706
00:38:13,860 --> 00:38:17,500
dan Anda memiliki kunci publik.

707
00:38:17,500 --> 00:38:21,390
Kita tidak akan, seperti yang saya katakan,
membahasnya lebih banyak lagi.

708
00:38:21,390 --> 00:38:25,310
Saya lebih tertarik
menjelaskan algoritma ini

709
00:38:25,310 --> 00:38:26,960
untuk enkripsi kunci publik.

710
00:38:26,960 --> 00:38:31,410
Kita akan melihat pasangan yang
menghasilkan teks terenkripsi dari

711
00:38:31,410 --> 00:38:34,440
sebuah pesan dan sebuah kunci publik.

712
00:38:34,440 --> 00:38:37,130
Sekarang, tentu saja,
apa yang Bob perlu lakukan

713
00:38:37,130 --> 00:38:41,670
adalah mengambil teks terenkripsi tersebut.

714
00:38:41,670 --> 00:38:43,750
Dan inilah yang Bob lakukan.

715
00:38:43,750 --> 00:38:53,360
Dan Bob memiliki kunci privat yang
berbeda dari kunci publik

716
00:38:53,360 --> 00:38:57,600
dan perlu mendapatkan kembali
pesannya menggunakan algoritma

717
00:38:57,600 --> 00:39:01,680
dekripsi yang sesuai dengan
pesan yang dikirim Alice.

718
00:39:01,680 --> 00:39:02,720
Oke.

719
00:39:02,720 --> 00:39:10,010
Dan semua hal ini akan
berhasil asalkan

720
00:39:10,010 --> 00:39:15,010
diketahui kunci publik,
sebut saja dengan PK (public key),

721
00:39:15,010 --> 00:39:16,060
dan kunci privat.

722
00:39:16,060 --> 00:39:17,990
Kita tidak bisa menyebutnya PK
juga, sudah jelas.

723
00:39:17,990 --> 00:39:19,960
Jadi kita menyebutnya SK (secret key).

724
00:39:19,960 --> 00:39:26,770
Mengetahui PK tidak
mengungkapkan apa pun

725
00:39:26,770 --> 00:39:33,290
secara matematis
pengertian tentang SK.

726
00:39:33,290 --> 00:39:36,740
Tapi jelas, agar
semua ini berhasil,

727
00:39:36,740 --> 00:39:42,950
PK dan SK harus memiliki beberapa
relasi matematis.

728
00:39:42,950 --> 00:39:46,070
Dan berbagai kriptosistem
termasuk RSA,

729
00:39:46,070 --> 00:39:48,330
dan kita lihat
kriptosistem knapsack,

730
00:39:48,330 --> 00:39:53,310
semuanya memiliki algoritma yang
berbeda untuk enkripsi dan dekripsi.

731
00:39:53,310 --> 00:39:55,780
Dan mereka memiliki
relasi matematis yang berbeda

732
00:39:55,780 --> 00:39:57,440
antara PK dan SK.

733
00:39:57,440 --> 00:40:00,320
Dan untuk setiap
relasi ini,

734
00:40:00,320 --> 00:40:03,260
Anda harus menunjukkan
bahwa lawan harus

735
00:40:03,260 --> 00:40:06,580
memecahkan masalah komputasi
yang sulit agar

736
00:40:06,580 --> 00:40:12,140
bisa menemukan SK dari PK yang ada.

737
00:40:12,140 --> 00:40:14,870
Dan ternyata untuk sebagian
besar sistem ini,

738
00:40:14,870 --> 00:40:19,330
itu bersifat simetris dalam arti
bahwa algoritma-algoritma ini,

739
00:40:19,330 --> 00:40:23,120
setidaknya untuk RSA, Anda
bisa menggunakan salah

740
00:40:23,120 --> 00:40:25,690
satu dari ini secara bergantian.

741
00:40:25,690 --> 00:40:27,390
Dan terdapat isu-isu
terkait hal tersebut.

742
00:40:27,390 --> 00:40:30,120
Sehingga kita tidak akan membahas
terlalu dalam ke sana.

743
00:40:30,120 --> 00:40:35,660
Tapi apa yang saya bilang Anda
harus pegang, di mana anda memilikinya,

744
00:40:35,660 --> 00:40:38,360
seharusnya tidak memberitahu Anda
apapun tentang yang lainnya.

745
00:40:38,360 --> 00:40:40,760
Harus ada masalah
komputasi sulit

746
00:40:40,760 --> 00:40:44,790
yang terkait dengan
menemukan salah satu dari ini

747
00:40:44,790 --> 00:40:48,350
jika hanya diketahui salah satunya.

748
00:40:48,350 --> 00:40:50,410
Dan kita akan membicarakan
apa saja asumsi

749
00:40:50,410 --> 00:40:53,580
kesulitan yang pasti untuk
RSA dan juga

750
00:40:53,580 --> 00:40:57,730
untuk kriptosistem yang lain,
sebuah knapsack.

751
00:40:57,730 --> 00:41:00,270
Jadi kita akan
mempresentasikan RSA, yang

752
00:41:00,270 --> 00:41:02,400
merupakan algoritma ajaib yang nyata ini.

753
00:41:02,400 --> 00:41:04,580
Luar biasa bahwa hal ini dapat bekerja.

754
00:41:04,580 --> 00:41:08,100
Setiap kali saya bersiap
untuk kuliah ini,

755
00:41:08,100 --> 00:41:10,130
Saya perlu mempelajari ulang sesuatu.

756
00:41:10,130 --> 00:41:17,370
Dan itu karena ada satu aspek
yang sulit diproses pada hal ini.

757
00:41:17,370 --> 00:41:18,580
Itu semua tentang adalah teori bilangan.

758
00:41:18,580 --> 00:41:21,190
Teori bilangan bisa
jadi cukup mendasar.

759
00:41:21,190 --> 00:41:26,850
Tapi itu juga cukup rumit
sampai saya lupa detailnya.

760
00:41:26,850 --> 00:41:30,030
Jadi mari kita mulai.

761
00:41:30,030 --> 00:41:37,300
Pada dasarnya, RSA didasarkan dari
bilangan prima dan memfaktorkan bilangan

762
00:41:37,300 --> 00:41:42,760
menjadi bilangan prima dan
menggunakan teori bilangan

763
00:41:42,760 --> 00:41:45,820
untuk memastikan bahwa Anda
benar-benar dapat mencapai

764
00:41:45,820 --> 00:41:49,050
apa yang sedang dicoba hal ini.

765
00:41:49,050 --> 00:41:51,580
Fungsionalitas
RSA harusnya

766
00:41:51,580 --> 00:41:55,550
berbeda dari
keamanan RSA.

767
00:41:55,550 --> 00:41:57,450
Ketika kita membicarakan tentang
fungsionalitas RSA,

768
00:41:57,450 --> 00:42:01,390
kita mengatakan untuk
setiap pesan, jika Alice

769
00:42:01,390 --> 00:42:05,270
menggunakan kunci publik Bob
untuk mengenkripsinya,

770
00:42:05,270 --> 00:42:07,780
teks terenkripsi
yang dihasilkan itu

771
00:42:07,780 --> 00:42:11,700
harus bisa didekripsi
tepat seperti pesan

772
00:42:11,700 --> 00:42:16,220
yang dikirim Alice dengan
kunci privat Bob.

773
00:42:16,220 --> 00:42:18,240
Itulah kebutuhan
fungsional

774
00:42:18,240 --> 00:42:21,120
dari algoritma enkripsi
kunci publik

775
00:42:21,120 --> 00:42:23,220
atau sebuah kriptosistem kunci publik.

776
00:42:23,220 --> 00:42:26,690
Persyaratan keamanan dari
sebuah kriptosistem kunci publik

777
00:42:26,690 --> 00:42:28,520
adalah yang saya tulis di atas sana.

778
00:42:28,520 --> 00:42:32,540
Bahwa pengetahuan tentang SK (secret key)
harus disembunyikan bahkan

779
00:42:32,540 --> 00:42:33,790
saat PK (public key) diketahui.

780
00:42:33,790 --> 00:42:36,190
Dan terdapat asumsi
tingkat kesulitan komputasi

781
00:42:36,190 --> 00:42:39,460
yang berkaitan
dengan setiap sistem kripto.

782
00:42:39,460 --> 00:42:41,745
Jadi mari pisahkan
fungsionalitas dari keamanan.

783
00:42:41,745 --> 00:42:43,370
Kita akan berbicara
tentang fungsionalitas

784
00:42:43,370 --> 00:42:44,411
untuk beberapa menit kedepan.

785
00:42:47,760 --> 00:43:00,970
Alice akan memilih dua
bilangan prima rahasia yang besar, p dan q.

786
00:43:00,970 --> 00:43:02,660
Jadi apa yang akan saya
jelaskan di sini

787
00:43:02,660 --> 00:43:07,480
adalah Alice menghasilkan
kunci publik dan kunci privatnya.

788
00:43:07,480 --> 00:43:09,960
Dia kemudian akan
mempublikasikan kunci publiknya

789
00:43:09,960 --> 00:43:12,360
dan merahasiakan kunci privatnya.

790
00:43:12,360 --> 00:43:14,160
Bob juga melakukan hal yang sama.

791
00:43:14,160 --> 00:43:16,760
Dan setelah itu,
mereka harus mendaftar.

792
00:43:16,760 --> 00:43:20,120
Dan ini bukan sesuatu yang akan
kita bahas, selain bahwa saya

793
00:43:20,120 --> 00:43:21,360
mengatakannya sekali lagi.

794
00:43:21,360 --> 00:43:23,820
Mereka harus mendaftarkan
kunci publik mereka dengan VeriSign

795
00:43:23,820 --> 00:43:26,190
atau dengan RMV seperti yang sudah saya bicarakan.

796
00:43:26,190 --> 00:43:30,380
Jadi semua orang tahu bahwa kunci
publik Alice adalah bilangan yang panjang ini.

797
00:43:30,380 --> 00:43:33,500
Tapi tidak ada yang tahu
kunci privat milik Alice.

798
00:43:33,500 --> 00:43:35,860
Jadi Alice memilih dua
bilangan prima rahasia yang besar.

799
00:43:35,860 --> 00:43:38,240
Jadi ini benar-benar
akan berujung pada

800
00:43:38,240 --> 00:43:40,560
pembuatan
kunci privat kita.

801
00:43:40,560 --> 00:43:48,600
Dan kemudian Alice
menghitung N sama dengan pq.

802
00:43:48,600 --> 00:43:51,320
Sehingga dia tinggal
mengalikannya.

803
00:43:51,320 --> 00:44:00,660
Dia memilih sebuah
eksponen enkripsi,

804
00:44:00,660 --> 00:44:07,600
e, yang memenuhi persamaan
kecil ini, yang

805
00:44:07,600 --> 00:44:11,560
mengatakan bahwa bilangan tersebut
relatif prima terhadap

806
00:44:11,560 --> 00:44:14,880
p dikurang 1 dikali q dikurang 1.

807
00:44:14,880 --> 00:44:15,910
Dan dia tahu nilai p dan q.

808
00:44:15,910 --> 00:44:19,550
Sehingga dia dapat menghitung p
dikurang 1 dikali q dikurang 1.

809
00:44:19,550 --> 00:44:24,010
Jadi hasil gcd dari e dan p
dikurang 1, q dikurang 1 adalah 1.

810
00:44:24,010 --> 00:44:26,740
Dan Anda pasti bisa
menyelesaikan hal ini hanya

811
00:44:26,740 --> 00:44:29,890
dengan memilih e sebagai bilangan prima.

812
00:44:29,890 --> 00:44:34,600
Karena dengan demikian hasil gcd dari bilangan
prima dengan bilangan apapun adalah 1.

813
00:44:34,600 --> 00:44:39,130
Dan ternyata RSA menggunakan--
semua ini akan menjadi publik,

814
00:44:39,130 --> 00:44:41,370
omong-omong.

815
00:44:41,370 --> 00:44:42,560
e akan menjadi publik.

816
00:44:42,560 --> 00:44:44,080
Jadi Anda bisa membuatnya konstan.

817
00:44:44,080 --> 00:44:48,470
Dan kebanyakan algoritma RSA hanya
menetapkannya ke sebuah bilangan kecil.

818
00:44:48,470 --> 00:44:51,430
Eksponen enkripsinya adalah
bilangan kecil.

819
00:44:51,430 --> 00:44:52,910
Dan alasan bilangannya
bernilai kecil

820
00:44:52,910 --> 00:44:55,160
adalah karena Anda khawatir
terhadap kinerja.

821
00:44:55,160 --> 00:44:57,500
Dan kita akan melakukan
eksponensial menggunakan e.

822
00:44:57,500 --> 00:44:59,750
Dan semakin kecil bilangannya,
semakin cepat enkripsinya

823
00:44:59,750 --> 00:45:00,910
akan berjalan.

824
00:45:00,910 --> 00:45:04,530
Jadi jika Anda ingin mengenkripsi
cepat dan mendekripsi lebih lambat,

825
00:45:04,530 --> 00:45:06,910
sayangnya, itulah
pertimbangannya di sini.

826
00:45:06,910 --> 00:45:08,127
Anda akan memilih sebuah e kecil.

827
00:45:08,127 --> 00:45:10,710
Dan kemudian kita akan menghitung
eksponen dekripsi milik kita, yang

828
00:45:10,710 --> 00:45:12,650
sudah jelas akan
perlu menjadi privat.

829
00:45:12,650 --> 00:45:14,470
Karena itu adalah bagian
dari kunci privat kita.

830
00:45:14,470 --> 00:45:16,810
Tapi dia akan menjadi
lebih besar jika e bernilai kecil.

831
00:45:16,810 --> 00:45:18,349
Dan itu adalah pertimbangannya.

832
00:45:18,349 --> 00:45:20,140
Hal itu simetris dalam
arti walaupun dia adalah

833
00:45:20,140 --> 00:45:21,940
sebuah algoritma
asimetris, itu semacam

834
00:45:21,940 --> 00:45:24,290
simetris pada
artian matematis

835
00:45:24,290 --> 00:45:28,160
di mana operasi kunci privat dan
operasi kunci publik

836
00:45:28,160 --> 00:45:30,910
bersifat simetris.

837
00:45:30,910 --> 00:45:33,015
Jadi apakah kunci publik milik Alice?

838
00:45:33,015 --> 00:45:39,540
Nah, kunci publik milik Alice,
yang nantinya dapat dia publikasikan,

839
00:45:39,540 --> 00:45:42,130
benar-benar hanyalah m, e.

840
00:45:42,130 --> 00:45:42,630
Oke.

841
00:45:50,740 --> 00:45:53,920
Sekarang, bagian yang menyenangkan dimulai.

842
00:45:53,920 --> 00:45:56,520
Kita harus mencari tahu
dengan apa kunci privat itu

843
00:45:56,520 --> 00:45:58,070
akan berkorespondensi.

844
00:45:58,070 --> 00:46:02,220
Dan ternyata-- dan
ini adalah salah satu hal

845
00:46:02,220 --> 00:46:05,110
di mana kita bertanya-tanya bagaimana bisa
mereka terpikirkan hal ini?

846
00:46:05,110 --> 00:46:09,020
Dan itu masih
berlaku 40 tahun kemudian.

847
00:46:09,020 --> 00:46:15,155
Anda mendapatkan eksponen dekripsi
menggunakan algoritma Euclidean

848
00:46:15,155 --> 00:46:15,655
yang diperluas.

849
00:46:24,280 --> 00:46:30,490
Dan ini dilakukan Alice secara
rahasia, di mana yang Anda inginkan

850
00:46:30,490 --> 00:46:35,110
adalah memiliki relasi
di mana e dikali d sama dengan 1.

851
00:46:35,110 --> 00:46:41,230
Dan ini adalah mod p
dikurangi 1, q dikurangi 1.

852
00:46:41,230 --> 00:46:44,540
Dan ada algoritma
di luar sana yang

853
00:46:44,540 --> 00:46:50,150
dapat menemukan inversi
yang sesuai dengan d untuk e

854
00:46:50,150 --> 00:46:51,520
atau sebaliknya.

855
00:46:51,520 --> 00:46:53,810
Dan itu kompleksitas algoritmanya polinomial.

856
00:46:53,810 --> 00:46:58,149
Selama Anda tahu angka ini
di sini, mod p dikurangi 1, q dikurangi 1,

857
00:46:58,149 --> 00:46:59,940
dan Anda tahu bahwa Alice
mengetahuinya, Anda bisa

858
00:46:59,940 --> 00:47:02,210
mendapatkan eksponen dekripsi Anda.

859
00:47:02,210 --> 00:47:06,880
Dan biasanya, jika a bernilai kecil, seperti
yang saya katakan, d akan menjadi besar.

860
00:47:06,880 --> 00:47:09,590
Omong-omong, angka-angka
di sini, p dan q,

861
00:47:09,590 --> 00:47:12,710
akan menjadi sekitar
1.000 bit panjangnya.

862
00:47:12,710 --> 00:47:15,650
Jadi pada dasarnya-- kita
membicarakan tentang bilangan prima yang besar di sini.

863
00:47:15,650 --> 00:47:19,180
Dan n akan menjadi 2048
bit dalam kasus tersebut.

864
00:47:19,180 --> 00:47:27,010
Sehingga kunci privatnya,
kunci privatnya Alice,

865
00:47:27,010 --> 00:47:32,450
dapat Anda anggap sebagai d, p, q.

866
00:47:32,450 --> 00:47:35,255
Jadi sekarang, sudah jelas apa yang
publik dan apa yang privat.

867
00:47:35,255 --> 00:47:37,040
n dan e publik.

868
00:47:37,040 --> 00:47:40,950
d, p, dan q privat.

869
00:47:40,950 --> 00:47:43,030
Jadi itulah yang diatur untuk RSA.

870
00:47:43,030 --> 00:47:48,160
Dan itu sama sekali tidak memastikan
bahwa RSA akan menyelesaikan

871
00:47:48,160 --> 00:47:52,700
salah satu dari dua hal yang
kita butuhkan, yang pertama adalah

872
00:47:52,700 --> 00:47:57,490
fungsionalitas, bukti bahwa
mengenkripsi, dan kemudian mendekripsi

873
00:47:57,490 --> 00:48:00,470
sebuah pesan akan membuat Anda
mendapatkan kembali pesan itu.

874
00:48:00,470 --> 00:48:02,580
Jadi itu hal pertama yang
harus kita perhatikan.

875
00:48:02,580 --> 00:48:05,140
Dan pada bagian keamanannya
sebenarnya sedikit lebih mudah.

876
00:48:05,140 --> 00:48:07,190
Karena Anda bisa lihat
kita perlu

877
00:48:07,190 --> 00:48:11,460
membuat asumsi
tentang memfaktorkan bilangan prima

878
00:48:11,460 --> 00:48:13,050
dan seterusnya.

879
00:48:13,050 --> 00:48:15,690
Di sini, Anda bisa
langsung melihatnya.

880
00:48:15,690 --> 00:48:18,590
Asumsi terbesar
yang dibuat oleh RSA

881
00:48:18,590 --> 00:48:20,840
dilihat dari tingkat
kesulitan komputasi

882
00:48:20,840 --> 00:48:24,450
sederhananya adalah jika
penyerang melihat n,

883
00:48:24,450 --> 00:48:28,660
mereka seharusnya tidak dapat
memfaktorkannya menjadi p dan q.

884
00:48:28,660 --> 00:48:30,860
Karena jika mereka bisa
melakukannya, tamat sudah.

885
00:48:30,860 --> 00:48:35,870
Jadi hal itu sebenarnya lebih mudah
daripada argumen fungsionalitas.

886
00:48:35,870 --> 00:48:37,130
Jadi mengapa hal ini berhasil?

887
00:48:42,970 --> 00:48:46,080
Dan luar biasanya, kita benar-benar dapat
melakukannya dalam waktu sekitar 10 menit.

888
00:48:46,080 --> 00:48:49,350
Saya akan menjelaskan kepada Anda
mengapa hal ini bisa bekerja dalam 10 menit.

889
00:48:49,350 --> 00:48:53,570
Dan satu-satunya teorema
yang kita perlukan

890
00:48:53,570 --> 00:48:56,720
selain ini, yang
tidak akan saya setujui,

891
00:48:56,720 --> 00:49:01,130
karena Fermat telah membuktikannya
berabad-abad yang lalu,

892
00:49:01,130 --> 00:49:05,830
adalah Teorema Kecil
Fermat yang mengatakan

893
00:49:05,830 --> 00:49:12,020
bahwa ketika Anda memiliki
p yang menjadi bilangan prima--

894
00:49:12,020 --> 00:49:13,985
Anda dapat menganggap ini
sebagai kasus spesial.

895
00:49:23,870 --> 00:49:27,290
Anda mengambil m, dan m adalah
sebuah angka acak.

896
00:49:27,290 --> 00:49:34,760
Dan jika p adalah bilangan prima, maka
relasi ini akan berlaku.

897
00:49:34,760 --> 00:49:39,190
Jadi Anda memangkatkannya dengan p dikurangi
1, dan Anda mendapatkan 1, mod p.

898
00:49:39,190 --> 00:49:40,980
Jadi itulah Teorema
Kecil Fermat

899
00:49:40,980 --> 00:49:42,160
yang akan dibutuhkan.

900
00:49:42,160 --> 00:49:43,701
Dan kurang lebih
itulah satu-satunya hal

901
00:49:43,701 --> 00:49:47,980
yang harus Anda panggil di luar
semacam aritmatika modulo standar

902
00:49:47,980 --> 00:49:51,720
untuk menunjukkan bahwa RSA bekerja.

903
00:49:51,720 --> 00:49:53,010
Jadi apa yang terjadi di sini?

904
00:49:53,010 --> 00:49:58,734
Mari kita panggil phi p dikurang
1 dikali q dikurang 1.

905
00:49:58,734 --> 00:50:00,650
Jelas sekali, itu sudah pernah
muncul beberapa kali.

906
00:50:00,650 --> 00:50:03,190
Dan Anda juga dapat
merepresentasikannya menggunakan

907
00:50:03,190 --> 00:50:05,830
simbol yang lebih kecil dan sederhana.

908
00:50:05,830 --> 00:50:07,530
Jadi kita akan sebut itu phi.

909
00:50:07,530 --> 00:50:13,870
Dan kita akan katakan
bahwa d sama dengan 1.

910
00:50:13,870 --> 00:50:16,280
Mod phi diberikan kepada kita.

911
00:50:21,870 --> 00:50:28,490
Oleh karena itu, kita dapat mengatakan
bahwa ed itu sama dengan 1 ditambah k phi. 

912
00:50:31,080 --> 00:50:32,840
Jadi itu saja.

913
00:50:32,840 --> 00:50:34,510
Yang saya katakan hanyalah hasil sisanya.

914
00:50:34,510 --> 00:50:37,790
Kemudian Anda beralih ke mod
sehubungan dengan phi adalah 1.

915
00:50:37,790 --> 00:50:40,900
Jadi bilangan yang sesungguhnya
adalah 1 ditambah k dikali phi.

916
00:50:40,900 --> 00:50:43,300
k adalah suatu integer.

917
00:50:43,300 --> 00:50:46,390
Anggap itu sebagai
bilangan bulat positif.

918
00:50:46,390 --> 00:50:50,570
Ingat-ingat bahwa sekarang kita memiliki
p dan q ada di sebelah sana.

919
00:50:50,570 --> 00:50:52,440
Dan p dan q adalah bilangan prima.

920
00:50:52,440 --> 00:50:56,230
Jadi p dan q adalah bilangan prima.

921
00:50:56,230 --> 00:50:58,980
Dan mengingat itulah
kasusnya, kita benar-benar

922
00:50:58,980 --> 00:51:02,310
memiliki dua kasus untuk dianalisis.

923
00:51:02,310 --> 00:51:03,210
Oh, saya minta maaf.

924
00:51:03,210 --> 00:51:14,530
Saya melewatkan satu poin penting,
yang seharusnya saya sampaikan kepada Anda,

925
00:51:14,530 --> 00:51:16,360
yaitu saya memberikan ini pada Anda.

926
00:51:16,360 --> 00:51:20,050
Tetapi saya tidak benar-benar
memberitahu Anda apa yang sedang terjadi.

927
00:51:20,050 --> 00:51:23,040
Saya menyebutkannya secara
sepintas, pemangkatan.

928
00:51:23,040 --> 00:51:25,980
Tetapi saya tidak memberitahu Anda
sebenarnya apa algoritma

929
00:51:25,980 --> 00:51:28,670
enkripsinya dan apa
algoritma dekripsinya.

930
00:51:28,670 --> 00:51:30,250
Dan jelas sekali, Anda
membutuhkannya untuk

931
00:51:30,250 --> 00:51:31,270
membuktikan kebenaran mereka.

932
00:51:31,270 --> 00:51:32,853
Maksud saya, akan sangat
bagus jika Anda dapat

933
00:51:32,853 --> 00:51:33,990
membuktikan kebenaran hal ini.

934
00:51:33,990 --> 00:51:38,440
Ada algoritma yang
sedemikian rupa sehingga

935
00:51:38,440 --> 00:51:43,340
RSA berfungsi atau enkripsi
kunci publik berfungsi.

936
00:51:43,340 --> 00:51:46,240
Jadi ternyata hal itu
sangatlah mudah.

937
00:51:46,240 --> 00:51:48,660
c sama dengan m pangkat e.

938
00:51:48,660 --> 00:51:51,210
Dan itulah bagian
dari kegunaannya

939
00:51:51,210 --> 00:51:56,315
dan kekuatan dari RSA,
di mana Anda mengambil m

940
00:51:56,315 --> 00:51:58,860
dan Anda memangkatkannya.

941
00:51:58,860 --> 00:52:04,310
Dan Anda mengambil c dan
Anda memangkatkannya.

942
00:52:04,310 --> 00:52:06,350
Dan yang pertama adalah enkripsinya.

943
00:52:06,350 --> 00:52:08,480
Anda mendapatkan c
melalui enkripsi,

944
00:52:08,480 --> 00:52:10,440
seperti yang Anda lihat
di sana, teks terenkripsi.

945
00:52:10,440 --> 00:52:11,970
Dan m adalah teks biasa.

946
00:52:11,970 --> 00:52:13,500
Dan Anda mendapatkannya kembali.

947
00:52:13,500 --> 00:52:24,650
Jadi tujuan kita di sini adalah untuk menunjukkan
bahwa Anda pada dasarnya memiliki sesuatu

948
00:52:24,650 --> 00:52:31,660
di mana ketika Anda memangkatkan
m dengan ed,

949
00:52:31,660 --> 00:52:34,060
hal itu akan menghasilkan m.

950
00:52:36,730 --> 00:52:40,080
Untuk pilihan-pilihan yang
kita miliki, dari e dan d,

951
00:52:40,080 --> 00:52:43,160
kita telah menyiapkan d
sedemikian rupa sehingga m

952
00:52:43,160 --> 00:52:47,030
dipangkatkan ed-- karena jika
Anda langsung melakukan enkripsi

953
00:52:47,030 --> 00:52:51,754
diikuti dengan dekripsi, Anda
memangkatkannya dua kali.

954
00:52:51,754 --> 00:52:52,420
Masuk akal?

955
00:52:52,420 --> 00:52:54,510
Ajukan pertanyaan jika
hal ini tidak masuk akal.

956
00:52:54,510 --> 00:52:55,600
Hal ini penting.

957
00:52:55,600 --> 00:52:58,930
m dipangkatkan ed seharusnya
akan mengembalikan m.

958
00:52:58,930 --> 00:53:01,860
Dan jika Anda bisa menunjukkannya
untuk m apa pun, Anda selesai.

959
00:53:01,860 --> 00:53:03,920
Itulah fungsionalitas RSA.

960
00:53:03,920 --> 00:53:06,550
Baiklah.

961
00:53:06,550 --> 00:53:08,770
Jadi itulah enkripsi
dan dekripsi.

962
00:53:08,770 --> 00:53:13,140
Jadi sekarang mari kita
kembali ke sini.

963
00:53:13,140 --> 00:53:15,340
Sekarang, ed sama dengan 1 mod phi.

964
00:53:15,340 --> 00:53:16,670
Karena saya sudah mengaturnya.

965
00:53:16,670 --> 00:53:20,440
Ini adalah cara saya
menemukan d jika diberikan e.

966
00:53:20,440 --> 00:53:21,440
Jadi itu diberikan kepada saya.

967
00:53:21,440 --> 00:53:26,100
Itulah bagian yang disebut sebagai
fase pembuatan kunci RSA.

968
00:53:26,100 --> 00:53:29,140
Dan itulah
relasi matematis

969
00:53:29,140 --> 00:53:31,830
yang terus saya bicarakan
dalam hal relasi

970
00:53:31,830 --> 00:53:34,320
antara kunci publik
dan kunci privat.

971
00:53:34,320 --> 00:53:37,755
Jadi mengingat bahwa p dan q adalah
bilangan prima, saya memiliki 2 kasus.

972
00:53:43,530 --> 00:53:50,050
Kasus yang pertama adalah
gcd dari m, p

973
00:53:50,050 --> 00:53:54,620
tepat bernilai 1, yang
berarti itu pesan m.

974
00:53:54,620 --> 00:53:56,860
Jadi yang saya bandingkan
di sini, pada kedua kasus,

975
00:53:56,860 --> 00:53:58,220
adalah saya memiliki pesannya.

976
00:53:58,220 --> 00:53:59,920
Dan saya akan
memecah pesannya

977
00:53:59,920 --> 00:54:02,010
menjadi dua kategori berbeda.

978
00:54:02,010 --> 00:54:03,057
Itu saja.

979
00:54:03,057 --> 00:54:05,140
Ada semua jenis
pesan yang memungkinkan.

980
00:54:05,140 --> 00:54:06,670
Ini adalah bilangan apapun.

981
00:54:06,670 --> 00:54:10,410
Saya akan memecahnya menjadi
dua kategori, di mana salah satunya

982
00:54:10,410 --> 00:54:14,860
pesannya relatif 
prima dalam kaitannya dengan bilangan prima,

983
00:54:14,860 --> 00:54:16,080
p.

984
00:54:16,080 --> 00:54:17,710
Dan itu bukan kelipatan dari p.

985
00:54:17,710 --> 00:54:19,460
Itulah cara Anda
memikirkannya.

986
00:54:19,460 --> 00:54:24,100
Jelas, gcdmp akan
menjadi 2 jika M adalah 2p.

987
00:54:24,100 --> 00:54:28,850
Jadi kasus yang saya lihat
adalah gcd dari mp sama dengan 1.

988
00:54:28,850 --> 00:54:32,330
Dan selanjutnya kasus yang lain akan 
menjadi trivial, sebenarnya,

989
00:54:32,330 --> 00:54:38,060
yaitu gcd dari mp sama dengan p.

990
00:54:38,060 --> 00:54:42,110
Apakah saya mengatakan 2 ketika saya mengatakan
gcd dari 2p, p sama dengan 2?

991
00:54:42,110 --> 00:54:45,100
Ayolah.

992
00:54:45,100 --> 00:54:45,635
Bangun.

993
00:54:45,635 --> 00:54:46,260
Wah, itu saja.

994
00:54:46,260 --> 00:54:47,250
Sempurna.

995
00:54:47,250 --> 00:54:48,230
Bangun.

996
00:54:48,230 --> 00:54:49,710
Baik.

997
00:54:49,710 --> 00:54:53,551
Jadi gcd dari 2p dan p adalah p.

998
00:54:53,551 --> 00:54:54,675
Jadi itu adalah kedua kasusnya.

999
00:54:57,290 --> 00:54:59,060
Baiklah.

1000
00:54:59,060 --> 00:55:05,576
Jadi dengan Teorema
Kecil Fermat, ini

1001
00:55:05,576 --> 00:55:06,700
benar-benar teorema Fermat.

1002
00:55:06,700 --> 00:55:08,920
Dan karena dia memiliki teorema terakhir,
untuk beberapa alasan,

1003
00:55:08,920 --> 00:55:11,560
beberapa orang menyebutnya
Teorema Kecil.

1004
00:55:11,560 --> 00:55:12,960
Tapi itu teorema Fermat.

1005
00:55:12,960 --> 00:55:15,270
Dan kita tahu apa itu.

1006
00:55:15,270 --> 00:55:17,500
Saya baru saja menulisnya di sana.

1007
00:55:17,500 --> 00:55:21,810
Anda sekarang dapat menulis sesuatu
tentang apa yang akan saya lakukan

1008
00:55:21,810 --> 00:55:30,530
adalah saya hanya akan mengambil
m dipangkatkan p dikurangi 1,

1009
00:55:30,530 --> 00:55:32,030
yaitu 1.

1010
00:55:32,030 --> 00:55:33,600
Jadi hal ini adalah 1.

1011
00:55:33,600 --> 00:55:37,254
Dan kemudian saya akan memangkatkannya
dengan k kali q dikurang 1.

1012
00:55:37,254 --> 00:55:39,170
Dan Anda akan melihat mengapa saya
melakukannya sebentar lagi.

1013
00:55:39,170 --> 00:55:42,270
Karena di sini saya ingin mendapatkan
faktor 1 ditambah k phi di sini.

1014
00:55:42,270 --> 00:55:44,730
Jadi saya mengambil 1
dan memangkatkannya

1015
00:55:44,730 --> 00:55:47,570
dengan pangkat ini, yang jelas
akan memberi saya 1 kembali.

1016
00:55:47,570 --> 00:55:51,100
Jadi semua itu
mudah.

1017
00:55:51,100 --> 00:55:53,460
Dan kemudian saya akan
mengalikannya dengan m.

1018
00:55:53,460 --> 00:55:54,550
Baik.

1019
00:55:54,550 --> 00:56:02,310
Dan ini jelas
sama dengan m modulo p.

1020
00:56:02,310 --> 00:56:06,320
Karena yang saya lakukan
hanyalah mengalikannya dengan 1.

1021
00:56:06,320 --> 00:56:06,820
Baiklah.

1022
00:56:06,820 --> 00:56:08,310
Jadi mengapa saya melakukan ini?

1023
00:56:08,310 --> 00:56:12,500
Yah, saya melakukan ini, karena saya
ingin mengelompokkan kedua

1024
00:56:12,500 --> 00:56:13,570
pangkat ini.

1025
00:56:13,570 --> 00:56:16,990
Dan karena saya sudah
kehabisan ruang di sini,

1026
00:56:16,990 --> 00:56:19,750
biarkan saya menghapus dan
menyelesaikannya dengan benar.

1027
00:56:19,750 --> 00:56:21,940
Lagi pula kasus yang lainnya mudah.

1028
00:56:21,940 --> 00:56:30,376
Sehingga saya bisa menulis ini sebagai 1
ditambah k p dikurang 1 q dikurang 1.

1029
00:56:30,376 --> 00:56:36,450
Dan itu, tentu saja, merupakan
m dipangkatkan ed, kan?

1030
00:56:36,450 --> 00:56:42,050
Jadi apa yang saya lakukan di sini adalah,
karena 1 dikali m jelas hasilnya m,

1031
00:56:42,050 --> 00:56:45,910
tapi jika saya lihat,
ini adalah m dipangkatkan ed.

1032
00:56:45,910 --> 00:56:49,080
Jadi itu jelas m.

1033
00:56:49,080 --> 00:56:51,760
Itu saja.

1034
00:56:51,760 --> 00:56:55,160
Baru saja paham bahwa
ketika saya memiliki k phi

1035
00:56:55,160 --> 00:56:58,680
di sini, itu akan
berubah menjadi 1, pada dasarnya,

1036
00:56:58,680 --> 00:57:01,550
ketika Anda memangkatkannya.

1037
00:57:01,550 --> 00:57:05,350
Jadi itulah bagian yang sulitnya,
sebenarnya, ternyata,

1038
00:57:05,350 --> 00:57:09,400
untuk membuktikan kebenaran
RSA, hanya

1039
00:57:09,400 --> 00:57:12,770
memperkenalkan 1 ini
dipangkatkan sesuatu.

1040
00:57:12,770 --> 00:57:16,360
Sehingga bagian yang
lebih mudahnya adalah

1041
00:57:16,360 --> 00:57:20,560
kasus di mana m sebenarnya
adalah kelipatan dari p.

1042
00:57:20,560 --> 00:57:26,000
Sehingga Anda memiliki gcd
m, koma p sama dengan p.

1043
00:57:26,000 --> 00:57:31,940
Dan pada kasus ini, Anda tahu
bahwa m modulo p sebenarnya adalah 0.

1044
00:57:31,940 --> 00:57:34,360
Karena m adalah kelipatan dari p.

1045
00:57:34,360 --> 00:57:36,530
Jadi pada dasarnya Anda
memangkatkan 0.

1046
00:57:36,530 --> 00:57:37,860
Apa yang Anda lakukan dengan 0?

1047
00:57:37,860 --> 00:57:40,220
Anda akan mendapatkan
0 di kedua sisi.

1048
00:57:40,220 --> 00:57:44,790
Jadi Anda mengirimkan sebuah pesan
yang pada dasarnya adalah 0 modulo p

1049
00:57:44,790 --> 00:57:48,010
Dan ketika Anda mendekripsinya
di sisi itu, Anda mendapatkan 0.

1050
00:57:48,010 --> 00:57:54,800
Tetapi satu baris terakhir di sini
sesederhana m dipangkatkan ed

1051
00:57:54,800 --> 00:58:04,090
adalah m secara trivial semuanya ini
modulo p jika m adalah 0, kan?

1052
00:58:04,090 --> 00:58:05,784
Jadi itulah kasus yang mudah.

1053
00:58:05,784 --> 00:58:07,450
Jadi itu tadi benar-benar
cukup mudah.

1054
00:58:07,450 --> 00:58:10,640
Dalam satu kasus, kita mengambil 1 dan kita
memangkatkannya dan menunjukkan

1055
00:58:10,640 --> 00:58:12,170
hasilnya dalam beberapa langkah.

1056
00:58:12,170 --> 00:58:15,240
Pada kasus lain, Anda memiliki
pesan yang merupakan 0 modulo p.

1057
00:58:15,240 --> 00:58:16,370
Jadi ini sangat bagus.

1058
00:58:16,370 --> 00:58:17,870
Ini berhasil.

1059
00:58:17,870 --> 00:58:20,890
Dan apa yang terjadi di sini?

1060
00:58:20,890 --> 00:58:23,740
Saya mengatakan bahwa m pangkat
ed sama dengan m.

1061
00:58:23,740 --> 00:58:27,500
Dan apa yang saya lakukan di sini, tentu
saja, saya melakukan segalanya.

1062
00:58:27,500 --> 00:58:30,350
Jadi ini belum selesai,
sedikit bantuan di sini

1063
00:58:30,350 --> 00:58:35,120
saat saya beralih dan
berbicara tentang mod p.

1064
00:58:35,120 --> 00:58:37,410
Jadi saya punya mod p di sini.

1065
00:58:37,410 --> 00:58:39,340
Dan saya katakan p dan q adalah bilangan prima.

1066
00:58:39,340 --> 00:58:42,770
Dan melihat p terlebih dahulu.

1067
00:58:42,770 --> 00:58:45,690
Tapi apa yang harus saya lakukan,
untuk menyelesaikan ini,

1068
00:58:45,690 --> 00:58:47,880
biarkan saya melakukan ini 
di sini, adalah saya harus

1069
00:58:47,880 --> 00:58:50,541
melakukan argumen yang sama untuk q.

1070
00:58:50,541 --> 00:58:56,160
Dan saya akan 
menggabungkannya untuk n.

1071
00:58:56,160 --> 00:59:00,530
Dan alasannya adalah
karena saya memiliki n disini.

1072
00:59:00,530 --> 00:59:03,050
Jadi ingat n sama dengan p dikali q.

1073
00:59:03,050 --> 00:59:06,460
Enkripsi dan
dekripsi itu

1074
00:59:06,460 --> 00:59:09,580
akan dilakukan di modulo o.

1075
00:59:09,580 --> 00:59:13,210
Tentu saja, enkripsi harus 
dilakukan modulo n, karena n

1076
00:59:13,210 --> 00:59:15,760
hanyalah numor publik
yang Anda miliki

1077
00:59:15,760 --> 00:59:17,670
yang bisa dimodulo, benar?

1078
00:59:17,670 --> 00:59:21,440
Jadi apa yang telah saya lakukan di sini,
analisis ini untuk p,

1079
00:59:21,440 --> 00:59:26,550
dapat dilakukan hal yang sama untuk q.

1080
00:59:26,550 --> 00:59:29,250
Ini persis sama,
karena p adalah bilangan prima

1081
00:59:29,250 --> 00:59:31,710
dan q juga bilangan prima.

1082
00:59:31,710 --> 00:59:34,910
Tapi saya harus melakukan satu hal terakhir,
yaitu menempatkan dua

1083
00:59:34,910 --> 00:59:39,130
bilangan ini bersama dan mengatakan
bahwa n sama dengan p dikali q,

1084
00:59:39,130 --> 00:59:41,446
jadi semua perhitungan
matematis akan bekerja.

1085
00:59:41,446 --> 00:59:42,570
Biarkan saya menulis itu.

1086
00:59:42,570 --> 00:59:45,740
Ini tidak terlalu
sulit untuk dijelaskan,

1087
00:59:45,740 --> 00:59:47,750
setelah saya memilikinya di sini.

1088
00:59:47,750 --> 00:59:52,100
Jadi dalam kedua kasus p dan
q, so when I say both cases,

1089
00:59:52,100 --> 00:59:55,330
Yang saya maksud pk dan qk.

1090
00:59:55,330 --> 01:00:02,070
Saya punya m dipangkatkan
ed sama dengan m modulo p.

1091
01:00:02,070 --> 01:00:09,320
dan m dipangkat pd itu
sama saja dengan m mod q.

1092
01:00:09,320 --> 01:00:19,810
And since p and q
are distinct primes,

1093
01:00:19,810 --> 01:00:27,690
we can say that m raised
to ed equals m mod N.

1094
01:00:27,690 --> 01:00:31,410
And that essentially says c
raised to d, if you really

1095
01:00:31,410 --> 01:00:33,000
want to put it all
together, which

1096
01:00:33,000 --> 01:00:41,590
is m raised to e raised to
d, equals m mod N, which

1097
01:00:41,590 --> 01:00:45,530
of course is what we want here.

1098
01:00:45,530 --> 01:00:51,000
And this thing was also mod N.
This is mod N, mod N, mod N.

1099
01:00:51,000 --> 01:00:52,270
All right.

1100
01:00:52,270 --> 01:00:53,090
So that's RSA.

1101
01:00:53,090 --> 01:00:55,400
That's your first
public key algorithm,

1102
01:00:55,400 --> 01:00:57,560
the first public key
algorithm, at least

1103
01:00:57,560 --> 01:01:00,075
that stood the test of
time, still in use today.

1104
01:01:03,900 --> 01:01:06,430
From a standpoint
of computation,

1105
01:01:06,430 --> 01:01:09,670
this is the hardest part.

1106
01:01:09,670 --> 01:01:12,900
You have to exponentiate, and
you have these large numbers.

1107
01:01:12,900 --> 01:01:19,000
And as the years have rolled
by, RSA, as I've said,

1108
01:01:19,000 --> 01:01:20,400
withstood the test of time.

1109
01:01:20,400 --> 01:01:23,140
But the parameters
have increased.

1110
01:01:23,140 --> 01:01:25,210
Way back then in
the '70s, they were

1111
01:01:25,210 --> 01:01:28,960
thinking about 512-bit primes.

1112
01:01:28,960 --> 01:01:32,060
In fact, I can't recall
whether n was 512-bits or p

1113
01:01:32,060 --> 01:01:33,440
and q were 512-bits.

1114
01:01:33,440 --> 01:01:36,940
But if p and q were 512-bits,
then n would be 1024.

1115
01:01:36,940 --> 01:01:43,330
And now, NSA recommends
8192-bits for n.

1116
01:01:43,330 --> 01:01:44,660
So there's been an increase.

1117
01:01:44,660 --> 01:01:46,870
But the nice thing
is that it's not

1118
01:01:46,870 --> 01:01:52,040
like there's an exponential
increase in the computation.

1119
01:01:52,040 --> 01:01:55,910
Because the computation
is polynomially related

1120
01:01:55,910 --> 01:01:57,570
to the number of bits.

1121
01:01:57,570 --> 01:02:01,560
So if you double it, I
think, if I recall correctly,

1122
01:02:01,560 --> 01:02:04,430
decryption is going to
be the cube of that.

1123
01:02:04,430 --> 01:02:06,370
Or actually,
verifying signatures

1124
01:02:06,370 --> 01:02:07,820
is probably the cube of that.

1125
01:02:07,820 --> 01:02:11,470
But don't worry too
much about that.

1126
01:02:11,470 --> 01:02:15,950
The bottom line is
that as you double

1127
01:02:15,950 --> 01:02:18,050
the size of the
exponent, you're going

1128
01:02:18,050 --> 01:02:22,530
to have a fairly small
increase in the time required

1129
01:02:22,530 --> 01:02:26,460
to decrypt or to verify
a signature, et cetera.

1130
01:02:26,460 --> 01:02:32,270
But it has grown from
512 or 1024 to 8192.

1131
01:02:32,270 --> 01:02:35,160
And so hopefully,
you all understand

1132
01:02:35,160 --> 01:02:38,340
how RSA works to some extent.

1133
01:02:38,340 --> 01:02:44,270
I just will leave it at the
hardness assumptions here

1134
01:02:44,270 --> 01:02:50,050
are, like in the case of
Diffie-Hellman, two-fold.

1135
01:02:50,050 --> 01:02:56,170
And the first one is kind
of immediately obvious.

1136
01:02:56,170 --> 01:02:58,550
Just like it was the
case with Diffie-Hellman,

1137
01:02:58,550 --> 01:03:01,390
where you had g raised
to a flying about

1138
01:03:01,390 --> 01:03:04,130
and obviously that
has to hide a,

1139
01:03:04,130 --> 01:03:08,130
here you got N, capital
N, being published.

1140
01:03:08,130 --> 01:03:12,039
And if anybody could
take N and factor it,

1141
01:03:12,039 --> 01:03:13,580
there may be multiple
factorizations.

1142
01:03:13,580 --> 01:03:16,660
But you're going to get a
unique prime factorization.

1143
01:03:16,660 --> 01:03:19,240
So that's what you want, that
unique prime factorization

1144
01:03:19,240 --> 01:03:20,250
of N.

1145
01:03:20,250 --> 01:03:24,830
And if you get that, then
you've broken the System

1146
01:03:24,830 --> 01:03:27,180
because you know
what p and q are.

1147
01:03:27,180 --> 01:03:28,960
And so this is all
public in the sense

1148
01:03:28,960 --> 01:03:31,120
that this algorithm is public.

1149
01:03:31,120 --> 01:03:33,559
If you're using RSA, this
is what you're following.

1150
01:03:33,559 --> 01:03:35,100
So the person is
trying to figure out

1151
01:03:35,100 --> 01:03:38,170
what the two primes are
that together get multiplied

1152
01:03:38,170 --> 01:03:42,030
to form capital N. And so
that's a factorization problem.

1153
01:03:42,030 --> 01:03:52,300
And so RSA hardness
assumptions are given N,

1154
01:03:52,300 --> 01:03:59,230
hard to factor into p, comma q.

1155
01:03:59,230 --> 01:04:00,315
And this is factoring.

1156
01:04:03,740 --> 01:04:06,480
And then one other
thing, which is

1157
01:04:06,480 --> 01:04:09,320
given e-- so you're
not actually breaking

1158
01:04:09,320 --> 01:04:11,130
the entire cryptosystem.

1159
01:04:11,130 --> 01:04:14,860
But you're breaking
the privacy associated

1160
01:04:14,860 --> 01:04:17,680
with a particular message.

1161
01:04:17,680 --> 01:04:19,730
And so you could break
the privacy associated

1162
01:04:19,730 --> 01:04:20,820
with a particular message.

1163
01:04:20,820 --> 01:04:23,370
You're given e,
because that's public.

1164
01:04:23,370 --> 01:04:27,830
And you don't know
what p and q are.

1165
01:04:27,830 --> 01:04:34,260
But you know that e is
relatively prime with respect

1166
01:04:34,260 --> 01:04:38,680
to p minus 1, q minus 1,
because that's RSA algorithm.

1167
01:04:38,680 --> 01:04:40,480
And that's a publicly known.

1168
01:04:40,480 --> 01:04:45,030
And you also know c, which
is the ciphered text.

1169
01:04:45,030 --> 01:04:47,520
And so what you're doing is
you're trying to discover m.

1170
01:04:47,520 --> 01:04:50,780
So you're trying to break a
particular encryption that was

1171
01:04:50,780 --> 01:04:53,520
created by the RSA algorithm.

1172
01:04:53,520 --> 01:04:55,910
And you haven't discovered
the private key here.

1173
01:04:55,910 --> 01:04:59,450
That's only discoverable
through the factoring problem.

1174
01:04:59,450 --> 01:05:02,750
But you could break
security if you

1175
01:05:02,750 --> 01:05:13,440
can find m such that m
raised to e is c mod N.

1176
01:05:13,440 --> 01:05:16,076
So you're doing the
searching for an m.

1177
01:05:16,076 --> 01:05:17,450
So you're trying
to discover an m

1178
01:05:17,450 --> 01:05:19,500
that you can exponentiate
to get what you

1179
01:05:19,500 --> 01:05:20,790
have on the right-hand side.

1180
01:05:20,790 --> 01:05:23,840
Because clearly, you can compute
what's on the right-hand side.

1181
01:05:23,840 --> 01:05:25,890
So this is simply
called RSA problem.

1182
01:05:29,160 --> 01:05:31,510
So those are the two
computational assumptions

1183
01:05:31,510 --> 01:05:35,620
that you need to make in
order for RSA to be secure.

1184
01:05:35,620 --> 01:05:36,120
Cool.

1185
01:05:36,120 --> 01:05:36,703
Any questions?

1186
01:05:40,123 --> 01:05:43,477
AUDIENCE: [INAUDIBLE] center?

1187
01:05:43,477 --> 01:05:45,060
SRINIVAS DEVADAS:
So that's anonymity.

1188
01:05:45,060 --> 01:05:45,630
Yes.

1189
01:05:45,630 --> 01:05:47,840
There's ring cryptography.

1190
01:05:47,840 --> 01:05:49,980
And there's a whole
host of protocols.

1191
01:05:49,980 --> 01:05:54,550
I actually did some of them
based on RSA, where you can,

1192
01:05:54,550 --> 01:05:59,170
by collecting a bunch of
private keys together,

1193
01:05:59,170 --> 01:06:02,130
essentially set it up
so it can be verified

1194
01:06:02,130 --> 01:06:06,850
that the message came from
a collection of people,

1195
01:06:06,850 --> 01:06:10,680
but you can't tell which
person the message came from.

1196
01:06:10,680 --> 01:06:12,550
So there's just a
whole host of things.

1197
01:06:12,550 --> 01:06:14,400
There's thousands
of papers written.

1198
01:06:14,400 --> 01:06:15,740
There's a wonderful field.

1199
01:06:15,740 --> 01:06:19,850
I encourage you to look into
it if your interests are

1200
01:06:19,850 --> 01:06:21,110
inclined this way.

1201
01:06:21,110 --> 01:06:22,860
And it's just gone on and on.

1202
01:06:22,860 --> 01:06:25,870
It's become more important
with the internet.

1203
01:06:25,870 --> 01:06:29,970
RSA, the company, was probably
founded in the late '70s.

1204
01:06:29,970 --> 01:06:31,532
And they struggled for a while.

1205
01:06:31,532 --> 01:06:32,990
And then eventually,
they were used

1206
01:06:32,990 --> 01:06:35,720
for Secure Sockets
Layer in Netscape,

1207
01:06:35,720 --> 01:06:37,060
which was their big break.

1208
01:06:37,060 --> 01:06:40,510
And then, of course, Netscape
meant the internet was around.

1209
01:06:40,510 --> 01:06:44,140
And so really, the internet
made RSA what it is today.

1210
01:06:44,140 --> 01:06:46,740
And so just a whole
host of wonderful

1211
01:06:46,740 --> 01:06:48,360
algorithms out
there, some of which

1212
01:06:48,360 --> 01:06:51,050
are based in RSA and
some that are broken.

1213
01:06:51,050 --> 01:06:53,750
And so let's talk for
the last few minutes

1214
01:06:53,750 --> 01:07:01,020
about all of the fits and starts
that occurred in cryptography.

1215
01:07:01,020 --> 01:07:04,440
And precisely what
I'd like to focus on

1216
01:07:04,440 --> 01:07:07,640
for the time we have
left is hardness.

1217
01:07:07,640 --> 01:07:11,010
So we spent a lot of time
talking about hard problems.

1218
01:07:11,010 --> 01:07:17,600
And we talked about NP-complete
problems that are hard.

1219
01:07:17,600 --> 01:07:20,760
But they're hard
in the worst case.

1220
01:07:20,760 --> 01:07:30,250
So you have a situation where
you have NP-complete problems.

1221
01:07:39,396 --> 01:07:40,770
And I'd like to
talk a little bit

1222
01:07:40,770 --> 01:07:44,030
about the relationship between
NP-completeness and crypto.

1223
01:07:44,030 --> 01:07:46,660
Because we've made these
assumptions about hardness.

1224
01:07:46,660 --> 01:07:53,000
Now, what's interesting here
is that N composite is clearly

1225
01:07:53,000 --> 01:08:02,940
in NP, but unknown
if NP-complete.

1226
01:08:02,940 --> 01:08:04,380
So this is very interesting.

1227
01:08:04,380 --> 01:08:08,290
The tried and trusted algorithm
for public key encryption

1228
01:08:08,290 --> 01:08:10,450
relies on a
computational assumption

1229
01:08:10,450 --> 01:08:12,660
where the problem associated
with that assumption

1230
01:08:12,660 --> 01:08:14,810
is not even known to be NPC.

1231
01:08:14,810 --> 01:08:15,930
All right.

1232
01:08:15,930 --> 01:08:17,920
So that's kind of wild.

1233
01:08:17,920 --> 01:08:19,430
So how does this work?

1234
01:08:19,430 --> 01:08:21,210
Or why does this work?

1235
01:08:21,210 --> 01:08:25,854
Now, if you take other problems,
like, is a graph 3-colorable?

1236
01:08:29,840 --> 01:08:31,790
And so what does that mean?

1237
01:08:31,790 --> 01:08:33,810
Well, you have three colors.

1238
01:08:33,810 --> 01:08:41,580
And you're not allowed
to reuse the same color

1239
01:08:41,580 --> 01:08:45,189
on two ends of an edge.

1240
01:08:45,189 --> 01:08:49,580
So if you put red over
here, you can put red here,

1241
01:08:49,580 --> 01:08:51,800
but you can't put
red here and there.

1242
01:08:51,800 --> 01:08:53,890
And so that graph
is 3-colorable.

1243
01:08:53,890 --> 01:08:59,410
But if you had a click, then
this would not be 3-colorable.

1244
01:08:59,410 --> 01:09:01,439
Because you have
all these edges.

1245
01:09:01,439 --> 01:09:02,899
You have three edges coming out.

1246
01:09:02,899 --> 01:09:05,700
And so clearly, the
degree from a vertex

1247
01:09:05,700 --> 01:09:07,420
is going to tell
you what you have.

1248
01:09:07,420 --> 01:09:09,270
So if you have a
4-click over there,

1249
01:09:09,270 --> 01:09:11,020
immediately it's
not 3-colorable.

1250
01:09:11,020 --> 01:09:14,890
But checking whether a
graphic is 3-colorable is NPC.

1251
01:09:20,330 --> 01:09:25,800
You can use a three set
as a way of showing that.

1252
01:09:25,800 --> 01:09:31,770
So you can say, oh, wow, maybe I
shouldn't be worried about RSA.

1253
01:09:31,770 --> 01:09:33,880
I should just be
building cryptosystems

1254
01:09:33,880 --> 01:09:35,210
based on 3-colorability.

1255
01:09:35,210 --> 01:09:38,380
Because it seems like a much
simpler problem than all

1256
01:09:38,380 --> 01:09:40,609
these grungy map that you
have out there-- actually,

1257
01:09:40,609 --> 01:09:42,490
beautiful map that
you have out there.

1258
01:09:42,490 --> 01:09:43,250
OK.

1259
01:09:43,250 --> 01:09:47,550
So that's something that's a
perfectly reasonable question

1260
01:09:47,550 --> 01:09:48,560
to ask.

1261
01:09:48,560 --> 01:09:51,370
And then we have Knapsack.

1262
01:09:51,370 --> 01:09:55,850
Knapsack is simply you've
got a bunch of items

1263
01:09:55,850 --> 01:09:59,290
and you just want to
figure out whether you

1264
01:09:59,290 --> 01:10:06,940
can get this particular sum
S. Knapsack is NPC as well.

1265
01:10:11,620 --> 01:10:14,110
And you got a bunch of
weights given to you.

1266
01:10:14,110 --> 01:10:17,350
And the BI are going
to have to be 0, 1.

1267
01:10:17,350 --> 01:10:20,740
So you just want to discover
a particular assignment

1268
01:10:20,740 --> 01:10:24,770
of the BIs, such that you pick
the appropriate items to put

1269
01:10:24,770 --> 01:10:26,350
into the knapsack, right?

1270
01:10:26,350 --> 01:10:27,110
That's it.

1271
01:10:27,110 --> 01:10:29,830
That's a perfectly
reasonable problem

1272
01:10:29,830 --> 01:10:33,760
to potentially use as a basis
for computational hardness

1273
01:10:33,760 --> 01:10:36,060
to go build cryptosystems.

1274
01:10:36,060 --> 01:10:37,530
And people did that.

1275
01:10:37,530 --> 01:10:38,940
People did that for years.

1276
01:10:38,940 --> 01:10:40,670
They tried and they tried.

1277
01:10:40,670 --> 01:10:43,770
And they produced cryptosystems,
public key cryptosystems,

1278
01:10:43,770 --> 01:10:48,350
based on Knapsack
that look fantastic.

1279
01:10:48,350 --> 01:10:50,970
And they work from a
functionality standpoint

1280
01:10:50,970 --> 01:10:53,609
in the sense that you
would use this Knapsack--

1281
01:10:53,609 --> 01:10:55,150
and I'll give you
a sense of how this

1282
01:10:55,150 --> 01:11:01,390
is done in a minute--
problem to encrypt.

1283
01:11:01,390 --> 01:11:03,830
And then you'd use a different
kind of Knapsack problem

1284
01:11:03,830 --> 01:11:05,260
to decrypt.

1285
01:11:05,260 --> 01:11:07,240
And when you encrypt
it and decrypt it,

1286
01:11:07,240 --> 01:11:09,100
you did get that
same message back,

1287
01:11:09,100 --> 01:11:11,720
except the whole world
knew what the message was.

1288
01:11:11,720 --> 01:11:15,810
Because the problem
associated with the Knapsack

1289
01:11:15,810 --> 01:11:17,760
wasn't hard enough.

1290
01:11:17,760 --> 01:11:20,540
So the computational
hardness was what

1291
01:11:20,540 --> 01:11:22,660
broke the Knapsack schemes.

1292
01:11:22,660 --> 01:11:25,680
And then you come
down to asking why

1293
01:11:25,680 --> 01:11:31,820
is it that this problem
that's not an NPC

1294
01:11:31,820 --> 01:11:34,310
seems to have stood
the test of time,

1295
01:11:34,310 --> 01:11:36,850
but all these other
problems, like Knapsack

1296
01:11:36,850 --> 01:11:39,790
and 3-colorability, which
is even worse than Knapsack,

1297
01:11:39,790 --> 01:11:42,540
when people have built
cryptosystems based on this,

1298
01:11:42,540 --> 01:11:45,220
they've all been
broken very quickly?

1299
01:11:45,220 --> 01:11:47,210
And so why is that?

1300
01:11:47,210 --> 01:11:54,340
What do you think the reason
is, sort of at a high level?

1301
01:11:54,340 --> 01:11:55,600
What does NP-completenss say?

1302
01:11:59,740 --> 01:12:03,389
When we talk about complexity,
what are we worried about?

1303
01:12:03,389 --> 01:12:04,930
Most of the time,
what are we talking

1304
01:12:04,930 --> 01:12:07,940
about when we talk about
complexity of an algorithm?

1305
01:12:07,940 --> 01:12:13,370
Or in this case, in the case
of a problem, what adjective

1306
01:12:13,370 --> 01:12:17,130
do we put in front of
runtime, for example,

1307
01:12:17,130 --> 01:12:18,627
then we compute complexity?

1308
01:12:18,627 --> 01:12:19,920
AUDIENCE: Worst [INAUDIBLE].

1309
01:12:19,920 --> 01:12:21,420
SRINIVAS DEVADAS:
Worst case, right?

1310
01:12:21,420 --> 01:12:23,080
Worst case.

1311
01:12:23,080 --> 01:12:25,790
In the worst case,
you're going to be

1312
01:12:25,790 --> 01:12:27,900
able to create
random graphs where

1313
01:12:27,900 --> 01:12:31,300
it takes exponential time
to discover whether they're

1314
01:12:31,300 --> 01:12:33,170
3-colorable or not.

1315
01:12:33,170 --> 01:12:35,370
But in the average
case, all you do

1316
01:12:35,370 --> 01:12:38,010
is if you have a large
graph, if there's

1317
01:12:38,010 --> 01:12:41,440
one little 4-click in the
graph and you can find it,

1318
01:12:41,440 --> 01:12:44,500
instantly you know that
it's not 3-colorable, right?

1319
01:12:44,500 --> 01:12:46,360
So it turns out that's
3-colorability is

1320
01:12:46,360 --> 01:12:49,740
just the worst thing ever
when it comes to cryptography.

1321
01:12:49,740 --> 01:12:51,770
Because the larger
the graph-- and you

1322
01:12:51,770 --> 01:12:53,020
need this graph to be large.

1323
01:12:53,020 --> 01:12:55,871
Because anything that's small,
is constant time, right?

1324
01:12:55,871 --> 01:12:57,370
Because so what if
it's exponential?

1325
01:12:57,370 --> 01:12:58,450
It's constant time.

1326
01:12:58,450 --> 01:13:00,620
So you need the
graph to be large.

1327
01:13:00,620 --> 01:13:03,340
When you have a random
graph that's large,

1328
01:13:03,340 --> 01:13:06,680
the chances you're going to
find a 4-click in a 2,000 vertex

1329
01:13:06,680 --> 01:13:09,120
graph is pretty high.

1330
01:13:09,120 --> 01:13:11,770
And so if you just go scan
and look for a 4-click,

1331
01:13:11,770 --> 01:13:14,330
instantly you know that this
graph is not 3-colorable,

1332
01:13:14,330 --> 01:13:14,830
right?

1333
01:13:14,830 --> 01:13:19,640
So in the average case,
3-colorability is easy.

1334
01:13:19,640 --> 01:13:22,590
It's easy to solve
in the average case.

1335
01:13:22,590 --> 01:13:26,540
And the wonderful
thing about factoring

1336
01:13:26,540 --> 01:13:29,390
is as long as the
numbers are large,

1337
01:13:29,390 --> 01:13:30,940
doesn't matter what
the numbers are,

1338
01:13:30,940 --> 01:13:33,822
it's hard to factor
in the average case.

1339
01:13:33,822 --> 01:13:35,030
So that's the big difference.

1340
01:13:35,030 --> 01:13:37,530
If you're going to take anything
away from the rest of this,

1341
01:13:37,530 --> 01:13:39,270
it's the difference
between problems

1342
01:13:39,270 --> 01:13:44,070
that cryptographics
systems are based on.

1343
01:13:44,070 --> 01:13:46,270
The systems that have
stood the test of time,

1344
01:13:46,270 --> 01:13:49,320
they're based on problems
that are hard on the average.

1345
01:13:49,320 --> 01:13:53,720
And the NP-complete problems,
like the simple ones

1346
01:13:53,720 --> 01:13:57,600
here, are hard in
the worst case.

1347
01:13:57,600 --> 01:14:02,290
And this is also
true for Knapsack.

1348
01:14:02,290 --> 01:14:05,000
So that's the essence of it.

1349
01:14:05,000 --> 01:14:07,450
I'll just give you a sense.

1350
01:14:07,450 --> 01:14:09,650
You can read the notes.

1351
01:14:09,650 --> 01:14:14,140
There's a way of
generating secret keys

1352
01:14:14,140 --> 01:14:17,250
and public keys using
Knapsack that I think

1353
01:14:17,250 --> 01:14:20,800
is kind of interesting
that is worth looking at,

1354
01:14:20,800 --> 01:14:23,090
even though all of these
systems are broken.

1355
01:14:23,090 --> 01:14:24,380
It's just kind of cool.

1356
01:14:24,380 --> 01:14:26,980
You know, how would you get
encryption out of a knapsack?

1357
01:14:26,980 --> 01:14:28,200
I mean, you're putting
things in a knapsack

1358
01:14:28,200 --> 01:14:29,320
and taking things out.

1359
01:14:29,320 --> 01:14:33,170
How can you set it up so you
get an asymmetric key system,

1360
01:14:33,170 --> 01:14:35,657
a public key system,
through a Knapsack problem?

1361
01:14:35,657 --> 01:14:37,240
So I'll just give
you a sense of that.

1362
01:14:37,240 --> 01:14:38,090
And you can read.

1363
01:14:38,090 --> 01:14:39,150
I won't finish.

1364
01:14:39,150 --> 01:14:44,840
But I'd like to do what we
did here for RSA in the time

1365
01:14:44,840 --> 01:14:47,490
that I have left for Knapsack.

1366
01:14:47,490 --> 01:14:49,140
That is kind of cool.

1367
01:14:49,140 --> 01:14:51,530
You get a sense of the variety
of different public key

1368
01:14:51,530 --> 01:14:54,760
cryptosystems that are out there
by looking at something that

1369
01:14:54,760 --> 01:14:57,180
is very different from RSA.

1370
01:14:59,940 --> 01:15:12,140
So in the Knapsack problem,
the general Knapsack problem,

1371
01:15:12,140 --> 01:15:14,720
what's hard is NPC.

1372
01:15:14,720 --> 01:15:24,250
There's a super increasing
Knapsack problem that's easy,

1373
01:15:24,250 --> 01:15:29,290
that can be solved
in linear time.

1374
01:15:29,290 --> 01:15:31,960
What is a super
increasing knapsack?

1375
01:15:31,960 --> 01:15:34,140
Well, a super
increasing knapsack

1376
01:15:34,140 --> 01:15:45,460
is something where I
Wj has this property.

1377
01:15:45,460 --> 01:15:55,074
So an example of that
is 2, 3, 6, 13, 27, 52.

1378
01:15:55,074 --> 01:15:56,490
So the rates are
super increasing.

1379
01:15:56,490 --> 01:15:58,100
2 plus 3 is less than 6.

1380
01:15:58,100 --> 01:16:02,150
2 plus 3 plus 6 is less than
13 and so on and so forth.

1381
01:16:02,150 --> 01:16:07,330
Do you see why super increasing
knapsack is easily solvable?

1382
01:16:07,330 --> 01:16:08,560
I mean, what is a knapsack?

1383
01:16:08,560 --> 01:16:10,960
I got a limit on
the amount of stuff

1384
01:16:10,960 --> 01:16:12,500
I can put into the knapsack.

1385
01:16:12,500 --> 01:16:16,470
And I want to make to be able
to say yes or no in terms

1386
01:16:16,470 --> 01:16:19,120
of whether it fits
exactly or not, just

1387
01:16:19,120 --> 01:16:20,900
in terms of our definition.

1388
01:16:20,900 --> 01:16:25,650
So what I do here in
super increasing knapsack?

1389
01:16:25,650 --> 01:16:26,893
Yep.

1390
01:16:26,893 --> 01:16:29,258
AUDIENCE: [INAUDIBLE]
from the biggest

1391
01:16:29,258 --> 01:16:30,857
to the smallest [INAUDIBLE].

1392
01:16:30,857 --> 01:16:31,940
SRINIVAS DEVADAS: Exactly.

1393
01:16:31,940 --> 01:16:33,880
That means that there's a
linear time algorithm that

1394
01:16:33,880 --> 01:16:35,300
basically solves the problem.

1395
01:16:35,300 --> 01:16:38,730
And you know that
you can do that,

1396
01:16:38,730 --> 01:16:40,850
and you would get
the correct answer.

1397
01:16:40,850 --> 01:16:42,840
So that's pretty
much what you've got.

1398
01:16:42,840 --> 01:16:45,710
That'll give you
the highest weight.

1399
01:16:45,710 --> 01:16:49,100
If you have 13 exactly, you
know you can't put 52 and 27.

1400
01:16:49,100 --> 01:16:50,170
You get 13.

1401
01:16:50,170 --> 01:16:52,580
There's no point in
putting 2 and 3 and 6,

1402
01:16:52,580 --> 01:16:56,400
because that's not
going to give you 13.

1403
01:16:56,400 --> 01:16:57,920
So that's clearly easy.

1404
01:16:57,920 --> 01:17:00,827
So we've got an
interesting case here,

1405
01:17:00,827 --> 01:17:02,410
assuming this is all
going to work out

1406
01:17:02,410 --> 01:17:05,670
from an adversarial standpoint,
which unfortunately it doesn't,

1407
01:17:05,670 --> 01:17:09,920
you can look and say, ah,
I want encryption to be

1408
01:17:09,920 --> 01:17:12,070
the super increasing knapsack.

1409
01:17:12,070 --> 01:17:14,730
Because that should
be easy to do.

1410
01:17:14,730 --> 01:17:21,630
And I want the decryption,
not knowing the private key,

1411
01:17:21,630 --> 01:17:23,580
to be as hard as knapsack.

1412
01:17:23,580 --> 01:17:24,250
OK.

1413
01:17:24,250 --> 01:17:25,999
So that's the kind of
thing that you could

1414
01:17:25,999 --> 01:17:29,550
do if you built a cryptosystem.

1415
01:17:29,550 --> 01:17:31,550
And people did,
Merkle and Hellman.

1416
01:17:31,550 --> 01:17:34,600
Hellman is the same guy, the
second name, in Diffie-Hellman.

1417
01:17:34,600 --> 01:17:38,970
They proposed this particular
system that ended up

1418
01:17:38,970 --> 01:17:40,830
being broken soon after.

1419
01:17:40,830 --> 01:17:43,410
But the idea is that you
create a private key.

1420
01:17:46,150 --> 01:17:48,645
And the private key is a
super increasing knapsack.

1421
01:17:54,980 --> 01:18:03,570
And then you use a
private transform in order

1422
01:18:03,570 --> 01:18:08,270
to get a-- and this is
really I put it in quotes,

1423
01:18:08,270 --> 01:18:14,725
because this was the bug--
"hard" Knapsack problem.

1424
01:18:17,650 --> 01:18:21,010
And this corresponded
to the public key.

1425
01:18:25,500 --> 01:18:27,860
And so what you do
is you won't actually

1426
01:18:27,860 --> 01:18:32,459
have to solve Knapsack for
encryption, the hard problem.

1427
01:18:32,459 --> 01:18:34,000
The encryption would
just simply take

1428
01:18:34,000 --> 01:18:36,810
the public key, which
is completely public,

1429
01:18:36,810 --> 01:18:41,120
and you would create
the encryption

1430
01:18:41,120 --> 01:18:45,450
of a message using this
particular public key

1431
01:18:45,450 --> 01:18:49,680
in a polynomial time.

1432
01:18:49,680 --> 01:18:54,830
But the inversion, not
knowing the private key,

1433
01:18:54,830 --> 01:18:57,820
you would force the
adversary to solve

1434
01:18:57,820 --> 01:19:00,050
what you think was hard
general Knapsack problem

1435
01:19:00,050 --> 01:19:03,920
to actually break the scheme
or to get the decryption.

1436
01:19:03,920 --> 01:19:07,210
And so let me show you
really quickly how this

1437
01:19:07,210 --> 01:19:08,230
works with numbers.

1438
01:19:08,230 --> 01:19:11,850
And we won't have you worry
about symbols and things

1439
01:19:11,850 --> 01:19:12,820
like that.

1440
01:19:12,820 --> 01:19:16,924
So just give me a couple
of extra minutes here.

1441
01:19:16,924 --> 01:19:18,340
So let's say that
I had a message.

1442
01:19:22,310 --> 01:19:26,960
Oh, before I do that, let
me look at-- let's say,

1443
01:19:26,960 --> 01:19:31,200
that we chose N equals
31 and M equals 105.

1444
01:19:31,200 --> 01:19:32,750
This is actually the message.

1445
01:19:36,520 --> 01:19:37,950
No, I'm sorry.

1446
01:19:37,950 --> 01:19:39,260
Capital M is not the message.

1447
01:19:39,260 --> 01:19:43,150
These are public parameters.

1448
01:19:43,150 --> 01:19:47,900
And we're going to take--
this is a transform.

1449
01:19:52,037 --> 01:19:52,620
Oh, I'm sorry.

1450
01:19:52,620 --> 01:19:53,660
These are not public.

1451
01:19:53,660 --> 01:19:54,600
These are private.

1452
01:19:54,600 --> 01:19:57,210
My bad.

1453
01:19:57,210 --> 01:19:58,710
So what I'm going
to show you is I'm

1454
01:19:58,710 --> 01:20:00,830
going to take a super
increasing Knapsack.

1455
01:20:00,830 --> 01:20:02,620
And that's exactly
what I have up there.

1456
01:20:02,620 --> 01:20:05,580
So that corresponds to
an easy Knapsack problem.

1457
01:20:05,580 --> 01:20:09,540
I'm going to convert it using
these private parameters,

1458
01:20:09,540 --> 01:20:12,480
N equals 31 and M equals 105.

1459
01:20:12,480 --> 01:20:17,310
And so our private key is our
super increasing knapsack,

1460
01:20:17,310 --> 01:20:23,720
which is 2, 3, 6,
13, 27, and 52.

1461
01:20:23,720 --> 01:20:29,920
And the public key,
what I'm going to do

1462
01:20:29,920 --> 01:20:37,310
is simply multiply each
of these, 2 times N.

1463
01:20:37,310 --> 01:20:42,950
And I'm going to take mod M.
So for each of those values,

1464
01:20:42,950 --> 01:20:46,560
I multiplied by N, which is
31, and take the mod of 105,

1465
01:20:46,560 --> 01:20:55,480
and I end up getting 62,
93, 81, 88, 102, and 37.

1466
01:20:55,480 --> 01:21:01,250
So you can get a private
key and a public key

1467
01:21:01,250 --> 01:21:03,649
using this private transform.

1468
01:21:03,649 --> 01:21:04,940
I'll let you look at the notes.

1469
01:21:04,940 --> 01:21:06,550
But basically what
happens is when

1470
01:21:06,550 --> 01:21:10,030
you take a particular
message M, what you end up

1471
01:21:10,030 --> 01:21:13,680
doing is you want to encrypt
it using the public key, which

1472
01:21:13,680 --> 01:21:15,690
is this quantity over here.

1473
01:21:15,690 --> 01:21:18,860
And the way you
encrypt that is simply

1474
01:21:18,860 --> 01:21:22,090
by taking a particular message.

1475
01:21:22,090 --> 01:21:26,770
And let's say that the
message is written as 011000.

1476
01:21:26,770 --> 01:21:30,880
Then all you do is
add up 93 and 81,

1477
01:21:30,880 --> 01:21:32,440
because those are those two.

1478
01:21:32,440 --> 01:21:37,200
And you say this is going
to get encrypted by 174.

1479
01:21:37,200 --> 01:21:39,500
So the message
encryption is simply

1480
01:21:39,500 --> 01:21:43,430
a simple operation where you
add up weights of the knapsack.

1481
01:21:43,430 --> 01:21:46,320
So you end up
getting 174 out here.

1482
01:21:46,320 --> 01:21:52,250
And the hope is, of course,
that when adversary sees 174--

1483
01:21:52,250 --> 01:21:58,030
and this is the part where
things get a little iffy--

1484
01:21:58,030 --> 01:22:00,990
that it's hard-- you have to
think about lots of numbers

1485
01:22:00,990 --> 01:22:03,520
here, of course--
for the adversary

1486
01:22:03,520 --> 01:22:08,610
to figure out that that
174 is actually 93 plus 81.

1487
01:22:08,610 --> 01:22:10,490
OK.

1488
01:22:10,490 --> 01:22:14,470
So the diverse is not
necessarily an easy problem.

1489
01:22:14,470 --> 01:22:16,400
And that's exactly what
Knapsack is, right?

1490
01:22:16,400 --> 01:22:19,840
I tell you what the sum
is over there, which is S.

1491
01:22:19,840 --> 01:22:21,710
And I tell you what
the weights are.

1492
01:22:21,710 --> 01:22:24,950
And it's hard for you to
figure out what the BIs are.

1493
01:22:24,950 --> 01:22:28,550
So now you see why
this didn't work.

1494
01:22:28,550 --> 01:22:31,650
So you have to have
a situation where

1495
01:22:31,650 --> 01:22:35,850
in the average case whatever you
produce for the ciphered text

1496
01:22:35,850 --> 01:22:38,685
here, you're sending out
the ciphered text according

1497
01:22:38,685 --> 01:22:41,140
to this cryptosystem,
which is 174,

1498
01:22:41,140 --> 01:22:45,390
and you want to make sure that
the adversary can't figure out

1499
01:22:45,390 --> 01:22:47,830
that this is
actually 93 plus 81.

1500
01:22:47,830 --> 01:22:50,480
Amazingly, people thought
they could build systems

1501
01:22:50,480 --> 01:22:52,770
using this assuming
these numbers were

1502
01:22:52,770 --> 01:22:54,500
much larger than they are here.

1503
01:22:54,500 --> 01:22:57,220
But that certainly
wasn't the case.

1504
01:22:57,220 --> 01:22:59,450
Because in the average
case, you end up

1505
01:22:59,450 --> 01:23:01,590
being able to break
these systems.

1506
01:23:01,590 --> 01:23:03,860
The last thing
is, of course, you

1507
01:23:03,860 --> 01:23:06,250
don't want to necessarily
solve the hard Knapsack

1508
01:23:06,250 --> 01:23:10,420
problem associated with this.

1509
01:23:10,420 --> 01:23:16,330
So what ends up happening is
you end up using N equals 31.

1510
01:23:16,330 --> 01:23:19,470
So if you want to decrypt,
you have N equals 31

1511
01:23:19,470 --> 01:23:21,620
and M equals 105.

1512
01:23:21,620 --> 01:23:25,240
And what you're going to do
is take this and multiply it

1513
01:23:25,240 --> 01:23:30,270
by N inverse mod M.

1514
01:23:30,270 --> 01:23:37,200
So rather than doing times N
mod M, you divide by N mod M.

1515
01:23:37,200 --> 01:23:40,720
And you can do this
operation relatively simply.

1516
01:23:40,720 --> 01:23:46,810
And you can go back
from 174 to figuring out

1517
01:23:46,810 --> 01:23:52,770
what the actual message was
by computing this quantity.

1518
01:23:52,770 --> 01:23:54,280
So I'll stop there.

1519
01:23:54,280 --> 01:23:56,720
I didn't quite get to everything
that I wanted to cover.

1520
01:23:56,720 --> 01:23:58,460
But take a look at the notes.

1521
01:23:58,460 --> 01:24:01,950
Get a sense for why
the difference exists

1522
01:24:01,950 --> 01:24:04,500
between NP-complete
problems and problems that

1523
01:24:04,500 --> 01:24:06,260
were used in cryptosystems.

1524
01:24:06,260 --> 01:24:10,100
And happy to stick around
and answer questions.
